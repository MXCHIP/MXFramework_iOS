// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.1.2 effective-5.10 (swiftlang-6.1.2.1.2 clang-1700.0.13.5)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name MeshSDK
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -interface-compiler-version 6.1.2
import CoreBluetooth
import CryptoSwift
import Foundation
@_exported import MeshSDK
import Security
import Swift
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public struct ConfigHeartbeatPublicationSet : AcknowledgedConfigMessage, ConfigNetKeyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: KeyIndex
  public let destination: Address
  public let countLog: Swift.UInt8
  public var count: RemainingHeartbeatPublicationCount {
    get
  }
  public let periodLog: Swift.UInt8
  public var period: Swift.UInt16 {
    get
  }
  public let ttl: Swift.UInt8
  public let features: NodeFeatures
  public var enablesPublication: Swift.Bool {
    get
  }
  public var enablesPeriodicPublication: Swift.Bool {
    get
  }
  public var enablesFeatureTriggeredPublication: Swift.Bool {
    get
  }
  public init()
  public init?(startSending countLog: Swift.UInt8, heartbeatMessagesEvery periodLog: Swift.UInt8, secondsTo destination: Address, usingTtl ttl: Swift.UInt8, andNetworkKey networkKey: NetworkKey, andEnableHeartbeatMessagesTriggeredByChangeOf features: NodeFeatures = [])
  public init?(startSendingHeartbeatMessagesTo destination: Address, usingTtl ttl: Swift.UInt8, andNetworkKey networkKey: NetworkKey, triggeredByChangeOf features: NodeFeatures)
  public init?(parameters: Foundation.Data)
}
public struct LightCTLTemperatureRangeGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct SensorSettingsGet : AcknowledgedSensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public let property: DeviceProperty
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: DeviceProperty)
  public init?(parameters: Foundation.Data)
}
public struct GenericDeltaSet : AcknowledgedGenericMessage, TransactionMessage, TransitionMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var continueTransaction: Swift.Bool
  public var parameters: Foundation.Data? {
    get
  }
  public let delta: Swift.Int32
  public let transitionTime: TransitionTime?
  public let delay: Swift.UInt8?
  public init(delta: Swift.Int32)
  public init(delta: Swift.Int32, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct LightCTLTemperatureRangeSetUnacknowledged : GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let min: Swift.UInt16
  public let max: Swift.UInt16
  public var range: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public init(_ range: Swift.ClosedRange<Swift.UInt16>)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLSetUnacknowledged : GenericMessage, TransactionMessage, TransitionMessage {
  public static var opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let hue: Swift.UInt16
  public let saturation: Swift.UInt16
  public let transitionTime: TransitionTime?
  public let delay: Swift.UInt8?
  public init(lightness: Swift.UInt16, hue: Swift.UInt16, saturation: Swift.UInt16)
  public init(lightness: Swift.UInt16, hue: Swift.UInt16, saturation: Swift.UInt16, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
extension Foundation.UserDefaults {
  public func lastSeqAuthValue(for source: Address) -> Swift.UInt64?
  public func storeLastSeqAuthValue(_ value: Swift.UInt64, for source: Address)
  public func previousSeqAuthValue(for source: Address) -> Swift.UInt64?
  public func storePreviousSeqAuthValue(_ value: Swift.UInt64, for source: Address)
  public func removeSeqAuthValues(of node: Node)
  public func removeSeqAuthValues(of source: Address)
}
public struct SensorGet : AcknowledgedSensorMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public let property: DeviceProperty?
  public var parameters: Foundation.Data? {
    get
  }
  public init(_ property: DeviceProperty? = nil)
  public init?(parameters: Foundation.Data)
}
@_hasMissingDesignatedInitializers public class ApplicationKey : Key, Swift.Codable {
  public var name: Swift.String
  public var index: KeyIndex {
    get
  }
  public var boundNetworkKeyIndex: KeyIndex {
    get
  }
  public var key: Foundation.Data {
    get
  }
  public var oldKey: Foundation.Data? {
    get
  }
  required public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
extension ApplicationKey : Swift.Equatable {
  public static func == (lhs: ApplicationKey, rhs: ApplicationKey) -> Swift.Bool
  public static func != (lhs: ApplicationKey, rhs: ApplicationKey) -> Swift.Bool
}
extension ApplicationKey : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct SensorColumnStatus : SensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public let property: DeviceProperty
  public let result: Foundation.Data
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: DeviceProperty, result: Foundation.Data)
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessLastGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightHSLHueGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct ConfigSIGModelSubscriptionList : ConfigModelSubscriptionList {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: ConfigMessageStatus
  public let elementAddress: Address
  public let modelIdentifier: Swift.UInt16
  public let addresses: [Address]
  public init(responseTo request: ConfigSIGModelSubscriptionGet, with addresses: [Address])
  public init(responseTo request: ConfigSIGModelSubscriptionGet, with status: ConfigMessageStatus)
  public init?(parameters: Foundation.Data)
}
extension Scene {
  public var isUsed: Swift.Bool {
    get
  }
}
extension Swift.Array where Element == Scene {
  public subscript(number: SceneNumber) -> Scene? {
    get
  }
}
public struct SensorSettingGet : AcknowledgedSensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public let property: DeviceProperty
  public let settingProperty: DeviceProperty
  public var parameters: Foundation.Data? {
    get
  }
  public init(_ setting: DeviceProperty, of property: DeviceProperty)
  public init?(parameters: Foundation.Data)
}
extension MeshSDK : ProxyFilterDelegate {
  @objc dynamic public func subscribeMeshProxyFilter(address: Swift.UInt16)
  @objc dynamic public func unsubscribeMeshProxyFilter(address: Swift.UInt16)
  public func proxyFilterUpdated(type: ProxyFilerType, addresses: Swift.Set<Address>)
  public func proxyFilterUpdateAcknowledged(type: ProxyFilerType, listSize: Swift.UInt16)
}
public struct LightLCOccupancyModeStatus : GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public init(_ mode: Swift.Bool)
  public init?(parameters: Foundation.Data)
}
public enum LogLevel : Swift.Int {
  case debug
  case verbose
  case info
  case application
  case warning
  case error
  public var name: Swift.String {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum LogCategory : Swift.String {
  case bearer
  case proxy
  case network
  case lowerTransport
  case upperTransport
  case access
  case foundationModel
  case model
  case provisioning
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol LoggerDelegate : AnyObject {
  func log(message: Swift.String, ofCategory category: LogCategory, withLevel level: LogLevel)
}
public struct LightHSLRangeSet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let minHue: Swift.UInt16
  public let maxHue: Swift.UInt16
  public let minSaturation: Swift.UInt16
  public let maxSaturation: Swift.UInt16
  public var hueRange: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public var saturationRange: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public init(hueRange: Swift.ClosedRange<Swift.UInt16>, saturationRange: Swift.ClosedRange<Swift.UInt16>)
  public init?(parameters: Foundation.Data)
}
public enum MeshMessageSecurity {
  case low
  case high
  public static func == (a: MeshMessageSecurity, b: MeshMessageSecurity) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol BaseMeshMessage {
  var parameters: Foundation.Data? { get }
  init?(parameters: Foundation.Data)
}
public protocol MeshMessage : BaseMeshMessage {
  var opCode: Swift.UInt32 { get }
  var security: MeshMessageSecurity { get }
  var isSegmented: Swift.Bool { get }
}
public protocol AcknowledgedMeshMessage : MeshMessage {
  var responseOpCode: Swift.UInt32 { get }
}
public protocol StaticMeshMessage : MeshMessage {
  static var opCode: Swift.UInt32 { get }
}
public protocol StaticAcknowledgedMeshMessage : AcknowledgedMeshMessage, StaticMeshMessage {
  static var responseType: any StaticMeshMessage.Type { get }
}
public protocol StatusMessage : MeshMessage {
  var isSuccess: Swift.Bool { get }
  var message: Swift.String { get }
}
public protocol TransactionMessage : MeshMessage {
  var tid: Swift.UInt8! { get set }
  var continueTransaction: Swift.Bool { get }
}
public protocol TransitionMessage : MeshMessage {
  var transitionTime: TransitionTime? { get }
  var delay: Swift.UInt8? { get }
}
public protocol TransitionStatusMessage : MeshMessage {
  var remainingTime: TransitionTime? { get }
}
extension MeshMessage {
  public var security: MeshMessageSecurity {
    get
  }
  public var isSegmented: Swift.Bool {
    get
  }
}
extension TransactionMessage {
  public var continueTransaction: Swift.Bool {
    get
  }
  public func isNewTransaction(previousTid: Swift.UInt8, timestamp: Foundation.Date) -> Swift.Bool
}
extension StaticMeshMessage {
  public var opCode: Swift.UInt32 {
    get
  }
}
extension StaticAcknowledgedMeshMessage {
  public var responseOpCode: Swift.UInt32 {
    get
  }
}
extension MeshMessageSecurity : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension NetworkKey {
  public var isPrimary: Swift.Bool {
    get
  }
  public var isSecondary: Swift.Bool {
    get
  }
  public func isUsed(in meshNetwork: MeshNetwork) -> Swift.Bool
}
public struct RemoveAddressesFromFilter : StaticAcknowledgedProxyConfigurationMessage {
  public static let opCode: Swift.UInt8
  public static let responseType: any StaticProxyConfigurationMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let addresses: Swift.Set<Address>
  public init(_ addresses: Swift.Set<Address>)
  public init?(parameters: Foundation.Data)
}
@objc @_inheritsConvenienceInitializers @objcMembers open class MXMeshProvisioning : ObjectiveC.NSObject {
  @objc public static let shared: MXMeshProvisioning
  @objc weak public var provisioningDelegate: (any MXMeshProvisioningDelegate)?
  public typealias MXMeshProvisioningCallback = (_ code: Swift.Int, _ nk: Swift.String, _ uuid: Swift.String, _ bearer: MXPBGattBearer) -> ()
  @objc public var provisioningCallback: MXMeshProvisioning.MXMeshProvisioningCallback?
  @objc override dynamic public init()
  @objc public func mxProvisioningCancel()
  @objc public func mxProvisioningFinish(_ code: Swift.Int)
  @objc deinit
  @objc convenience public init(device: UnprovisionedDevice, peripheral: CoreBluetooth.CBPeripheral, networkKey: Swift.String)
  @objc public func connectUnprovisionedDevice(device: UnprovisionedDevice, peripheral: CoreBluetooth.CBPeripheral, networkKey: Swift.String)
  @objc public func identifyNode()
  @objc public func setProvisionUnicastAddress(address: Swift.Int)
  @objc public func startProvisioning()
}
extension MXMeshProvisioning : ProvisioningDelegate {
  public func authenticationActionRequired(_ action: AuthAction)
  @objc dynamic public func inputComplete()
  public func provisioningState(of unprovisionedDevice: UnprovisionedDevice, didChangeTo state: ProvisioningState)
}
extension MXMeshProvisioning : GattBearerDelegate {
  public func bearer(_ bearer: any Bearer, didClose error: (any Swift.Error)?)
  public func bearerDidSwitchedToProxy(_ bearer: any Bearer)
  public func bearerDidOpen(_ bearer: any Bearer)
  public func bearerDidDiscoverServices(_ bearer: any Bearer)
  public func bearerDidConnect(_ bearer: any Bearer)
}
extension MXMeshProvisioning : LoggerDelegate {
  public func log(message: Swift.String, ofCategory category: LogCategory, withLevel level: LogLevel)
}
public enum LowerTransportError : Swift.Error {
  case timeout
  case busy
  case replayAttack
  public static func == (a: LowerTransportError, b: LowerTransportError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension LowerTransportError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public struct LightHSLSaturationStatus : GenericMessage, TransitionStatusMessage {
  public static var opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let saturation: Swift.UInt16
  public let targetSaturation: Swift.UInt16?
  public let remainingTime: TransitionTime?
  public init(saturation: Swift.UInt16)
  public init(saturation: Swift.UInt16, targetSaturation: Swift.UInt16, remainingTime: TransitionTime)
  public init?(parameters: Foundation.Data)
}
extension ApplicationKey {
  public func bind(to networkKey: NetworkKey) throws
  public func isBound(to networkKey: NetworkKey) -> Swift.Bool
  public func isBound(toAnyOf networkKeys: [NetworkKey]) -> Swift.Bool
  public var boundNetworkKey: NetworkKey {
    get
  }
}
extension Swift.Array where Element == ApplicationKey {
  public func contains(keyBoundTo networkKey: NetworkKey) -> Swift.Bool
  public func boundTo(_ networkKey: NetworkKey) -> [ApplicationKey]
  public func boundTo(_ networkKeys: [NetworkKey]) -> [ApplicationKey]
}
public class Provisioner : Swift.Codable {
  final public let uuid: Foundation.UUID
  public var name: Swift.String {
    get
    set
  }
  public var allocatedUnicastRange: [AddressRange] {
    get
  }
  public var allocatedGroupRange: [AddressRange] {
    get
  }
  public var allocatedSceneRange: [SceneRange] {
    get
  }
  public init(name: Swift.String, uuid: Foundation.UUID, allocatedUnicastRange: [AddressRange], allocatedGroupRange: [AddressRange], allocatedSceneRange: [SceneRange])
  convenience public init(name: Swift.String, allocatedUnicastRange: [AddressRange], allocatedGroupRange: [AddressRange], allocatedSceneRange: [SceneRange])
  convenience public init(name: Swift.String)
  required public init(from decoder: any Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Provisioner : Swift.Equatable {
  public static func == (lhs: Provisioner, rhs: Provisioner) -> Swift.Bool
  public static func != (lhs: Provisioner, rhs: Provisioner) -> Swift.Bool
}
public protocol SensorMessage : StaticMeshMessage {
}
public protocol AcknowledgedSensorMessage : SensorMessage, StaticAcknowledgedMeshMessage {
}
extension Swift.Array where Element == any SensorMessage.Type {
  public func toMap() -> [Swift.UInt32 : any MeshMessage.Type]
}
public protocol SensorPropertyMessage : SensorMessage {
  var property: DeviceProperty { get }
}
public protocol AcknowledgedSensorPropertyMessage : SensorPropertyMessage, StaticAcknowledgedMeshMessage {
}
public struct SensorDescriptor {
  public let property: DeviceProperty
  public let positiveTolerance: Swift.UInt16
  public let negativeTolerance: Swift.UInt16
  public let samplingFunction: SensorSamplingFunction
  public var isPositiveToleranceSpecified: Swift.Bool {
    get
  }
  public var isNegativeToleranceSpecified: Swift.Bool {
    get
  }
  public var measurementPeriod: Foundation.TimeInterval? {
    get
  }
  public var updateInteval: Foundation.TimeInterval? {
    get
  }
  public init(_ property: DeviceProperty, positiveTolerance: Swift.UInt16, negativeTolerance: Swift.UInt16, samplingFunction: SensorSamplingFunction, measurementPeriod: Swift.UInt8, updateInterval: Swift.UInt8)
}
public enum SensorSamplingFunction : Swift.UInt8 {
  case unspecified
  case instantaneous
  case arithmeticMean
  case rms
  case maximum
  case minimum
  case accumulated
  case count
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct SensorCadence {
  public enum StatusTriggerDelta {
    case values(down: DevicePropertyCharacteristic, up: DevicePropertyCharacteristic)
    case percentage(down: Swift.UInt16, up: Swift.UInt16)
  }
  public let fastCadencePeriodDivisor: Swift.UInt8
  public let statusTriggerDelta: SensorCadence.StatusTriggerDelta
  public let statusMinIntervalValue: Swift.UInt8
  public let fastCadenceLow: DevicePropertyCharacteristic
  public let fastCadenceHigh: DevicePropertyCharacteristic
  public var statusMinInterval: Foundation.TimeInterval {
    get
  }
  public init(increasePublishingFrequencyWithPeriodDivider divider: Swift.UInt8, whenValueIsAbove low: DevicePropertyCharacteristic, andBelow high: DevicePropertyCharacteristic, orChangesDownByMoreThan deltaDown: DevicePropertyCharacteristic, orUpBy deltaUp: DevicePropertyCharacteristic, withMinIntervalExponent minInterval: Swift.UInt8)
  public init(increasePublishingFrequencyWithPeriodDivider divider: Swift.UInt8, whenValueIsAbove low: DevicePropertyCharacteristic, andBelow high: DevicePropertyCharacteristic, orChangesDownByMoreThan deltaDown: Swift.UInt16, millipercentOrUpBy deltaUp: Swift.UInt16, millipercentWithMinIntervalExponent minInterval: Swift.UInt8)
}
extension SensorSamplingFunction : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Provisioner {
  public var unicastAddress: Address? {
    get
  }
  public var node: Node? {
    get
  }
  public var hasConfigurationCapabilities: Swift.Bool {
    get
  }
  public var isLocal: Swift.Bool {
    get
  }
}
public typealias Address = Swift.UInt16
extension Swift.UInt16 {
  public static let unassignedAddress: Address
  public static let minUnicastAddress: Address
  public static let mx_minUnicastAddress: Address
  public static let maxUnicastAddress: Address
  public static let minVirtualAddress: Address
  public static let maxVirtualAddress: Address
  public static let minGroupAddress: Address
  public static let maxGroupAddress: Address
  public static let allProxies: Address
  public static let allFriends: Address
  public static let allRelays: Address
  public static let allNodes: Address
}
extension Swift.UInt16 {
  public var isValidAddress: Swift.Bool {
    get
  }
  public var isUnassigned: Swift.Bool {
    get
  }
  public var isUnicast: Swift.Bool {
    get
  }
  public var isVirtual: Swift.Bool {
    get
  }
  public var isGroup: Swift.Bool {
    get
  }
  public var isSpecialGroup: Swift.Bool {
    get
  }
}
public struct ConfigLowPowerNodePollTimeoutStatus : ConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let lpnAddress: Address
  public let pollTimeout: Swift.UInt32
  public var pollTimeoutInterval: Foundation.TimeInterval? {
    get
  }
  public init?(of address: Address, pollTimeout: Swift.UInt32)
  public init(responseTo request: ConfigLowPowerNodePollTimeoutGet)
  public init?(parameters: Foundation.Data)
}
public struct FilterStatus : StaticProxyConfigurationMessage {
  public static let opCode: Swift.UInt8
  public var parameters: Foundation.Data? {
    get
  }
  public let filterType: ProxyFilerType
  public let listSize: Swift.UInt16
  public init(_ type: ProxyFilerType, listSize: Swift.UInt16)
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessRangeStatus : GenericMessage, GenericStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: GenericMessageStatus
  public let min: Swift.UInt16
  public let max: Swift.UInt16
  public var range: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public init(report range: Swift.ClosedRange<Swift.UInt16>)
  public init(_ status: GenericMessageStatus, for request: LightLightnessRangeSet)
  public init(_ status: GenericMessageStatus, for request: LightLightnessRangeSetUnacknowledged)
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessRangeSetUnacknowledged : GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let min: Swift.UInt16
  public let max: Swift.UInt16
  public var range: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public init(_ range: Swift.ClosedRange<Swift.UInt16>)
  public init?(parameters: Foundation.Data)
}
public struct ConfigBeaconStatus : ConfigMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let isEnabled: Swift.Bool
  public init(enabled: Swift.Bool)
  public init?(parameters: Foundation.Data)
}
@objc open class MXPBGattBearer : ObjectiveC.NSObject, MXProvisioningBearer, CoreBluetooth.CBCentralManagerDelegate, CoreBluetooth.CBPeripheralDelegate {
  public var mac: Swift.String?
  public var rssi: Swift.Int?
  weak public var delegate: (any BearerDelegate)?
  weak public var dataDelegate: (any BearerDataDelegate)?
  weak public var logger: (any LoggerDelegate)?
  public var supportedPduTypes: PduTypes {
    get
  }
  public var isOpen: Swift.Bool {
    get
  }
  final public let identifier: Foundation.UUID
  public var name: Swift.String? {
    get
  }
  public var peripheral: CoreBluetooth.CBPeripheral? {
    get
  }
  convenience public init(target peripheral: CoreBluetooth.CBPeripheral)
  public init(targetWithIdentifier uuid: Foundation.UUID)
  open func open()
  open func close()
  open func switchToProxyBearer() -> Swift.Bool
  open func send(_ data: Foundation.Data, ofType type: PduType) throws
  open func readRSSI()
  @objc open func centralManagerDidUpdateState(_ central: CoreBluetooth.CBCentralManager)
  @objc open func centralManager(_ central: CoreBluetooth.CBCentralManager, didConnect peripheral: CoreBluetooth.CBPeripheral)
  @objc open func centralManager(_ central: CoreBluetooth.CBCentralManager, didDisconnectPeripheral peripheral: CoreBluetooth.CBPeripheral, error: (any Swift.Error)?)
  @objc open func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didDiscoverServices error: (any Swift.Error)?)
  @objc open func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didDiscoverCharacteristicsFor service: CoreBluetooth.CBService, error: (any Swift.Error)?)
  @objc open func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didModifyServices invalidatedServices: [CoreBluetooth.CBService])
  @objc open func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didUpdateNotificationStateFor characteristic: CoreBluetooth.CBCharacteristic, error: (any Swift.Error)?)
  @objc open func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didUpdateValueFor characteristic: CoreBluetooth.CBCharacteristic, error: (any Swift.Error)?)
  @objc open func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didWriteValueFor characteristic: CoreBluetooth.CBCharacteristic, error: (any Swift.Error)?)
  @objc open func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didReadRSSI RSSI: Foundation.NSNumber, error: (any Swift.Error)?)
  @objc open func peripheralIsReady(toSendWriteWithoutResponse peripheral: CoreBluetooth.CBPeripheral)
  @objc deinit
}
public enum BearerError : Swift.Error {
  case centralManagerNotPoweredOn
  case pduTypeNotSupported
  case bearerClosed
  public static func == (a: BearerError, b: BearerError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension BearerError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public struct ConfigBeaconGet : AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct GenericDeltaSetUnacknowledged : GenericMessage, TransactionMessage, TransitionMessage {
  public static let opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var continueTransaction: Swift.Bool
  public var parameters: Foundation.Data? {
    get
  }
  public let delta: Swift.Int32
  public let transitionTime: TransitionTime?
  public let delay: Swift.UInt8?
  public init(delta: Swift.Int32)
  public init(delta: Swift.Int32, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct ConfigNetKeyGet : AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public protocol BearerDataDelegate : AnyObject {
  func bearer(_ bearer: any Bearer, didDeliverData data: Foundation.Data, ofType type: PduType)
}
public protocol BearerDelegate : AnyObject {
  func bearerDidOpen(_ bearer: any Bearer)
  func bearer(_ bearer: any Bearer, didClose error: (any Swift.Error)?)
}
public struct ConfigDefaultTtlGet : AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
@_hasMissingDesignatedInitializers public class Node : Swift.Codable {
  @_hasMissingDesignatedInitializers public class NodeKey : Swift.Codable {
    public var index: KeyIndex {
      get
    }
    public var updated: Swift.Bool {
      get
    }
    @objc deinit
    public func encode(to encoder: any Swift.Encoder) throws
    required public init(from decoder: any Swift.Decoder) throws
  }
  public struct NetworkTransmit : Swift.Codable {
    public let count: Swift.UInt8
    public let interval: Swift.UInt16
    public var steps: Swift.UInt8 {
      get
    }
    public var timeInterval: Foundation.TimeInterval {
      get
    }
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct RelayRetransmit : Swift.Codable {
    public let count: Swift.UInt8
    public let interval: Swift.UInt16
    public var steps: Swift.UInt8 {
      get
    }
    public var timeInterval: Foundation.TimeInterval {
      get
    }
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  final public let uuid: Foundation.UUID
  public var unicastAddress: Address {
    get
  }
  final public let deviceKey: Foundation.Data?
  final public let security: Security
  public var isConfigComplete: Swift.Bool {
    get
    set
  }
  public var name: Swift.String? {
    get
    set
  }
  public var companyIdentifier: Swift.UInt16? {
    get
  }
  public var productIdentifier: Swift.UInt16? {
    get
  }
  public var versionIdentifier: Swift.UInt16? {
    get
  }
  public var minimumNumberOfReplayProtectionList: Swift.UInt16? {
    get
  }
  public var features: NodeFeaturesState? {
    get
  }
  public var secureNetworkBeacon: Swift.Bool? {
    get
  }
  public var defaultTTL: Swift.UInt8? {
    get
    set
  }
  public var networkTransmit: Node.NetworkTransmit? {
    get
  }
  public var relayRetransmit: Node.RelayRetransmit? {
    get
  }
  public var elements: [Element]
  public var isExcluded: Swift.Bool {
    get
    set
  }
  public var networkKeys: [NetworkKey] {
    get
  }
  public var applicationKeys: [ApplicationKey] {
    get
  }
  public var heartbeatPublication: HeartbeatPublication? {
    get
  }
  public var heartbeatSubscription: HeartbeatSubscription? {
    get
  }
  public init?(insecureNode name: Swift.String?, with n: Swift.UInt8, elementsDeviceKey deviceKey: Foundation.Data, andAssignedNetworkKey networkKey: NetworkKey, andAddress address: Address)
  required public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
extension Node {
  public func add(element: Element)
  public func add(elements: [Element])
  public func set(elements: [Element])
  public func add(networkKey: NetworkKey)
  public func add(networkKeyWithIndex networkKeyIndex: KeyIndex)
  public func set(networkKeys: [NetworkKey])
  public func set(networkKeysWithIndexes networkKeyIndexes: [KeyIndex])
  public func update(networkKeyWithIndex networkKeyIndex: KeyIndex)
  public func add(applicationKey: ApplicationKey)
  public func add(applicationKeyWithIndex applicationKeyIndex: KeyIndex)
  public func set(applicationKeys: [ApplicationKey])
  public func set(applicationKeysWithIndexes applicationKeyIndexes: [KeyIndex])
  public func set(applicationKeysWithIndexes applicationKeyIndexes: [KeyIndex], forNetworkKeyWithIndex networkKeyIndex: KeyIndex)
  public func update(applicationKeyWithIndex applicationKeyIndex: KeyIndex)
  public func remove(networkKeyWithIndex networkKeyIndex: KeyIndex)
  public func remove(applicationKeyWithIndex applicationKeyIndex: KeyIndex)
  public func apply(compositionData: ConfigCompositionDataStatus)
  public var ensureFeatures: NodeFeaturesState {
    get
  }
}
extension Node.NodeKey : Swift.Comparable {
  public static func < (lhs: Node.NodeKey, rhs: Node.NodeKey) -> Swift.Bool
  public static func == (lhs: Node.NodeKey, rhs: Node.NodeKey) -> Swift.Bool
  public static func != (lhs: Node.NodeKey, rhs: Node.NodeKey) -> Swift.Bool
}
extension Node.NodeKey : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Node : Swift.Equatable {
  public static func == (lhs: Node, rhs: Node) -> Swift.Bool
}
public protocol MeshService {
  static var uuid: CoreBluetooth.CBUUID { get }
  static var dataInUuid: CoreBluetooth.CBUUID { get }
  static var dataOutUuid: CoreBluetooth.CBUUID { get }
  static func matches(_ service: CoreBluetooth.CBService) -> Swift.Bool
}
public struct MeshProvisioningService : MeshService {
  public static var uuid: CoreBluetooth.CBUUID
  public static var dataInUuid: CoreBluetooth.CBUUID
  public static var dataOutUuid: CoreBluetooth.CBUUID
  public static func matches(_ service: CoreBluetooth.CBService) -> Swift.Bool
}
public struct MeshProxyService : MeshService {
  public static var uuid: CoreBluetooth.CBUUID
  public static var dataInUuid: CoreBluetooth.CBUUID
  public static var dataOutUuid: CoreBluetooth.CBUUID
  public static func matches(_ service: CoreBluetooth.CBService) -> Swift.Bool
}
extension CoreBluetooth.CBService {
  public var isMeshProvisioningService: Swift.Bool {
    get
  }
  public var isMeshProxyService: Swift.Bool {
    get
  }
}
extension CoreBluetooth.CBCharacteristic {
  public var isMeshProvisioningDataInCharacteristic: Swift.Bool {
    get
  }
  public var isMeshProvisioningDataOutCharacteristic: Swift.Bool {
    get
  }
  public var isMeshProxyDataInCharacteristic: Swift.Bool {
    get
  }
  public var isMeshProxyDataOutCharacteristic: Swift.Bool {
    get
  }
}
open class BaseGattProxyBearer<Service> : ObjectiveC.NSObject, Bearer, CoreBluetooth.CBCentralManagerDelegate, CoreBluetooth.CBPeripheralDelegate where Service : MeshService {
  weak public var delegate: (any BearerDelegate)?
  weak public var dataDelegate: (any BearerDataDelegate)?
  weak public var logger: (any LoggerDelegate)?
  public var mac: Swift.String?
  public var supportedPduTypes: PduTypes {
    get
  }
  public var isOpen: Swift.Bool {
    get
  }
  final public let identifier: Foundation.UUID
  public var name: Swift.String? {
    get
  }
  public var peripheral: CoreBluetooth.CBPeripheral? {
    get
  }
  convenience public init(target peripheral: CoreBluetooth.CBPeripheral)
  public init(targetWithIdentifier uuid: Foundation.UUID)
  @objc deinit
  open func open()
  open func close()
  open func send(_ data: Foundation.Data, ofType type: PduType) throws
  open func readRSSI()
  @objc open func centralManagerDidUpdateState(_ central: CoreBluetooth.CBCentralManager)
  @objc open func centralManager(_ central: CoreBluetooth.CBCentralManager, didConnect peripheral: CoreBluetooth.CBPeripheral)
  @objc open func centralManager(_ central: CoreBluetooth.CBCentralManager, didDisconnectPeripheral peripheral: CoreBluetooth.CBPeripheral, error: (any Swift.Error)?)
  @objc open func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didDiscoverServices error: (any Swift.Error)?)
  @objc open func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didDiscoverCharacteristicsFor service: CoreBluetooth.CBService, error: (any Swift.Error)?)
  @objc open func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didModifyServices invalidatedServices: [CoreBluetooth.CBService])
  @objc open func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didUpdateNotificationStateFor characteristic: CoreBluetooth.CBCharacteristic, error: (any Swift.Error)?)
  @objc open func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didUpdateValueFor characteristic: CoreBluetooth.CBCharacteristic, error: (any Swift.Error)?)
  @objc open func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didWriteValueFor characteristic: CoreBluetooth.CBCharacteristic, error: (any Swift.Error)?)
  @objc open func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didReadRSSI RSSI: Foundation.NSNumber, error: (any Swift.Error)?)
  @objc open func peripheralIsReady(toSendWriteWithoutResponse peripheral: CoreBluetooth.CBPeripheral)
}
extension CoreBluetooth.CBManagerState : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct ConfigVendorModelAppList : ConfigModelAppList, ConfigVendorModelMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: ConfigMessageStatus
  public let elementAddress: Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16
  public let applicationKeyIndexes: [KeyIndex]
  public init(responseTo request: ConfigVendorModelAppGet, with applicationKeys: [ApplicationKey])
  public init(responseTo request: ConfigVendorModelAppGet, with status: ConfigMessageStatus)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLHueSet : AcknowledgedGenericMessage, TransactionMessage, TransitionMessage {
  public static var opCode: Swift.UInt32
  public static var responseType: any StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let hue: Swift.UInt16
  public let transitionTime: TransitionTime?
  public let delay: Swift.UInt8?
  public init(hue: Swift.UInt16)
  public init(hue: Swift.UInt16, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct ConfigAppKeyStatus : ConfigNetAndAppKeyMessage, ConfigStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: KeyIndex
  public let applicationKeyIndex: KeyIndex
  public let status: ConfigMessageStatus
  public init(confirm applicationKey: ApplicationKey)
  public init(responseTo request: any ConfigNetAndAppKeyMessage, with status: ConfigMessageStatus)
  public init?(parameters: Foundation.Data)
}
extension Node {
  public var scenes: [Scene] {
    get
  }
}
public enum NodeFeature : Swift.String, Swift.Codable {
  case relay
  case proxy
  case friend
  case lowPower
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct NodeFeatures : Swift.OptionSet {
  public let rawValue: Swift.UInt16
  public static let relay: NodeFeatures
  public static let proxy: NodeFeatures
  public static let friend: NodeFeatures
  public static let lowPower: NodeFeatures
  public init(rawValue: Swift.UInt16)
  public typealias ArrayLiteralElement = NodeFeatures
  public typealias Element = NodeFeatures
  public typealias RawValue = Swift.UInt16
}
public enum NodeFeatureState : Swift.UInt8, Swift.Codable {
  case notEnabled
  case enabled
  case notSupported
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
@_hasMissingDesignatedInitializers public class NodeFeaturesState : Swift.Codable {
  public var relay: NodeFeatureState? {
    get
  }
  public var proxy: NodeFeatureState? {
    get
  }
  public var friend: NodeFeatureState? {
    get
  }
  public var lowPower: NodeFeatureState? {
    get
  }
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
extension NodeFeature : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension NodeFeatures : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension NodeFeatureState : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension NodeFeaturesState : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct LightHSLDefaultGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct ConfigGATTProxyStatus : ConfigMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let state: NodeFeatureState
  public init(_ state: NodeFeatureState)
  public init(for node: Node)
  public init?(parameters: Foundation.Data)
}
public struct LightLCModeGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct ConfigModelSubscriptionDelete : AcknowledgedConfigMessage, ConfigAddressMessage, ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let address: Address
  public let elementAddress: Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public init?(group: Group, from model: Model)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLDefaultStatus : GenericMessage {
  public static var opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let hue: Swift.UInt16
  public let saturation: Swift.UInt16
  public init(lightness: Swift.UInt16, hue: Swift.UInt16, saturation: Swift.UInt16)
  public init?(parameters: Foundation.Data)
}
public struct LightCTLGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public enum MeshNetworkError : Swift.Error {
  case overlappingProvisionerRanges
  case provisionerUsedInAnotherNetwork
  case nodeAlreadyExist
  case noAddressAvailable
  case addressNotAvailable
  case invalidAddress
  case addressNotInAllocatedRange
  case provisionerNotInNetwork
  case cannotRemove
  case invalidRange
  case invalidKey
  case keyInUse
  case groupAlreadyExists
  case sceneAlreadyExists
  case groupInUse
  case sceneInUse
  case keyIndexOutOfRange
  case noNetworkKey
  case noApplicationKey
  case noNetwork
  case ivIndexTooSmall
  public static func == (a: MeshNetworkError, b: MeshNetworkError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension MeshNetworkError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public protocol ProvisioningDelegate : AnyObject {
  func authenticationActionRequired(_ action: AuthAction)
  func inputComplete()
  func provisioningState(of unprovisionedDevice: UnprovisionedDevice, didChangeTo state: ProvisioningState)
}
public class ProvisioningManager {
  public var provisioningCapabilities: ProvisioningCapabilities? {
    get
  }
  public var unicastAddress: Address?
  public var suggestedUnicastAddress: Address? {
    get
  }
  public var networkKey: NetworkKey?
  weak public var delegate: (any ProvisioningDelegate)?
  weak public var logger: (any LoggerDelegate)?
  public var state: ProvisioningState {
    get
  }
  public var isUnicastAddressValid: Swift.Bool? {
    get
  }
  public var isDeviceSupported: Swift.Bool? {
    get
  }
  public init(for unprovisionedDevice: UnprovisionedDevice, over bearer: any ProvisioningBearer, in meshNetwork: MeshNetwork)
  public func identify(andAttractFor attentionTimer: Swift.UInt8) throws
  public func provision(usingAlgorithm algorithm: Algorithm, publicKey: PublicKey, authenticationMethod: AuthenticationMethod) throws
  public func removeBearer()
  public typealias StaticOOBProvisionConfirmationCallback = (_ provisionerRandom: Foundation.Data, _ deviceConfirmation: Foundation.Data, _ deviceRandom: Foundation.Data) -> ()
  public func updateProvisionerRandom(random: Foundation.Data)
  public func setOOBCheckCallBack(callback: @escaping ProvisioningManager.StaticOOBProvisionConfirmationCallback)
  public func getConfirmationKey() -> Swift.String
  public func sendProvisionerConfirmation(confirmation: Foundation.Data)
  public func checkStaticOOBInfoSuccess()
  @objc deinit
}
extension ProvisioningManager : BearerDelegate, BearerDataDelegate {
  public func bearerDidOpen(_ bearer: any Bearer)
  public func bearer(_ bearer: any Bearer, didClose error: (any Swift.Error)?)
  public func bearer(_ bearer: any Bearer, didDeliverData data: Foundation.Data, ofType type: PduType)
}
public struct ConfigBeaconSet : AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let state: Swift.Bool
  public init(enable: Swift.Bool)
  public init?(parameters: Foundation.Data)
}
public struct LightCTLTemperatureRangeSet : GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let min: Swift.UInt16
  public let max: Swift.UInt16
  public var range: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public init(_ range: Swift.ClosedRange<Swift.UInt16>)
  public init?(parameters: Foundation.Data)
}
public struct SceneStoreUnacknowledged : GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let scene: SceneNumber
  public init(_ scene: SceneNumber)
  public init?(parameters: Foundation.Data)
}
public struct GenericPowerDefaultSetUnacknowledged : GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let power: Swift.UInt16
  public init(power: Swift.UInt16)
  public init?(parameters: Foundation.Data)
}
public struct GenericOnPowerUpSetUnacknowledged : GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let state: OnPowerUp
  public init(state: OnPowerUp)
  public init?(parameters: Foundation.Data)
}
public enum StepResolution : Swift.UInt8 {
  case hundredsOfMilliseconds
  case seconds
  case tensOfSeconds
  case tensOfMinutes
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension StepResolution : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct ConfigNetworkTransmitSet : AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let count: Swift.UInt8
  public let steps: Swift.UInt8
  public var interval: Foundation.TimeInterval {
    get
  }
  public init(count: Swift.UInt8, steps: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct ConfigVendorModelAppGet : AcknowledgedConfigMessage, ConfigVendorModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let elementAddress: Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16
  public init?(of model: Model)
  public init?(parameters: Foundation.Data)
}
public protocol VendorMessage : MeshMessage {
}
public protocol AcknowledgedVendorMessage : AcknowledgedMeshMessage, VendorMessage {
}
public protocol StaticVendorMessage : StaticMeshMessage, VendorMessage {
}
public protocol AcknowledgedStaticVendorMessage : StaticAcknowledgedMeshMessage, StaticVendorMessage {
}
public protocol VendorStatusMessage : StatusMessage {
}
extension VendorMessage {
  public var opCode: Swift.UInt8 {
    get
  }
  public var companyIdentifier: Swift.UInt16 {
    get
  }
}
extension Swift.Array where Element == any StaticVendorMessage.Type {
  public func toMap() -> [Swift.UInt32 : any MeshMessage.Type]
}
@_hasMissingDesignatedInitializers public class MeshData : Swift.Codable {
  public var meshNetwork: MeshNetwork? {
    get
  }
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
public struct SensorSettingsStatus : SensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public let property: DeviceProperty
  public let settingsProperties: [DeviceProperty]?
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: DeviceProperty, settingsProperties: [DeviceProperty]?)
  public init?(parameters: Foundation.Data)
}
extension Node {
  public var primaryElement: Element? {
    get
  }
  public func element(withAddress address: Address) -> Element?
}
public struct ConfigDefaultTtlStatus : ConfigMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let ttl: Swift.UInt8
  public init(ttl: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
extension MeshSDK {
  @objc dynamic public func getAllNetworkKey() -> [Swift.String]
  @objc dynamic public func isNetworkKeyExists(networkKey: Swift.String) -> Swift.Bool
  @objc dynamic public func createNetworkKey(key: Swift.String, appKey: Swift.String?) -> Swift.Bool
  @objc dynamic public func createNetworkKey(key: Swift.String) -> Swift.Bool
  @objc dynamic public func deleteNetworkKey(key: Swift.String)
  @objc dynamic public func setCurrentNetworkKey(key: Swift.String)
  @objc dynamic public func getCurrentNetworkKey() -> Swift.String
}
extension MeshSDK {
  @objc dynamic public func getAllApplicationKey(networkKey: Swift.String) -> [Swift.String]
}
public struct ConfigNetworkTransmitStatus : ConfigMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let count: Swift.UInt8
  public let steps: Swift.UInt8
  public var interval: Foundation.TimeInterval {
    get
  }
  public init(count: Swift.UInt8, steps: Swift.UInt8)
  public init(for node: Node)
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessLinearGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct GenericPowerLevelGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct SensorColumnGet : AcknowledgedSensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public let property: DeviceProperty
  public let rawValueX: Foundation.Data
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: DeviceProperty, rawValueX: Foundation.Data)
  public init?(parameters: Foundation.Data)
}
extension MeshNetwork {
  public func group(withAddress address: MeshAddress) -> Group?
  public func group(withAddress address: Address) -> Group?
  public func add(group: Group) throws
  public func remove(group: Group) throws
  public func models(subscribedTo group: Group) -> [Model]
}
public struct ProvisioningCapabilities {
  public let numberOfElements: Swift.UInt8
  public let algorithms: Algorithms
  public let publicKeyType: PublicKeyType
  public let staticOobType: StaticOobType
  public let outputOobSize: Swift.UInt8
  public let outputOobActions: OutputOobActions
  public let inputOobSize: Swift.UInt8
  public let inputOobActions: InputOobActions
}
extension ProvisioningCapabilities : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct ConfigSIGModelAppList : ConfigModelAppList {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: ConfigMessageStatus
  public let elementAddress: Address
  public let modelIdentifier: Swift.UInt16
  public let applicationKeyIndexes: [KeyIndex]
  public init(responseTo request: ConfigSIGModelAppGet, with applicationKeys: [ApplicationKey])
  public init(responseTo request: ConfigSIGModelAppGet, with status: ConfigMessageStatus)
  public init?(parameters: Foundation.Data)
}
extension MeshNetwork {
  public func restoreIvIndex()
  public func setIvIndex(_ index: Swift.UInt32, updateActive: Swift.Bool) throws
}
public struct ConfigNetKeyAdd : AcknowledgedConfigMessage, ConfigNetKeyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: KeyIndex
  public let key: Foundation.Data
  public init(networkKey: NetworkKey)
  public init?(parameters: Foundation.Data)
}
@objc public protocol MXMeshDelegate {
  @objc optional func meshConnectChange(status: Swift.Int)
  @objc optional func provisionerSequenceUpdate(seq: Swift.Int)
  @objc optional func meshNetworkIvIndexUpdate(index: Swift.Int)
  @objc optional func receiveMeshMessage(uuid: Swift.String, elementIndex: Swift.Int, message: Swift.String)
}
@objc public protocol MXMeshProvisioningDelegate {
  @objc optional func inputExchangeInformation(uuid: Swift.String?, confirmationKey: Swift.String, handler: @escaping (_ uuid: Swift.String?, _ provisionerRandom: Swift.String?, _ provisionerConfirmation: Swift.String?, _ authValueKey: Swift.String?) -> Swift.Void)
  @objc optional func checkStaticOOBDeviceInfo(uuid: Swift.String?, provisionerRandom: Swift.String, deviceConfirmation: Swift.String, deviceRandom: Swift.String, handler: @escaping (_ uuid: Swift.String?, _ isSuccess: Swift.Bool) -> Swift.Void)
  @objc optional func inputPublicKey(uuid: Swift.String?, handler: @escaping (Swift.String) -> Swift.Void)
  @objc optional func inputUnicastAddress(uuid: Swift.String?, elementNum: Swift.Int, handler: @escaping (_ uuid: Swift.String?, _ address: Swift.Int) -> Swift.Void)
  @objc optional func meshProvisionProcess(uuid: Swift.String?, step: Swift.Int)
  @objc optional func meshProvisionFinish(uuid: Swift.String?, error: Foundation.NSError?)
}
public struct LightLCLightOnOffSetUnacknowledged : GenericMessage, TransactionMessage, TransitionMessage {
  public static let opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let isOn: Swift.Bool
  public let transitionTime: TransitionTime?
  public let delay: Swift.UInt8?
  public init(_ isOn: Swift.Bool)
  public init(_ isOn: Swift.Bool, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct SensorSeriesStatus : SensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public let property: DeviceProperty
  public let seriesRawData: Foundation.Data?
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: DeviceProperty, seriesRawData: Foundation.Data?)
  public init?(parameters: Foundation.Data)
}
public struct MeshAddress {
  public let address: Address
  public let virtualLabel: Foundation.UUID?
  public init?(hex: Swift.String)
  public init(_ address: Address)
  public init(_ virtualLabel: Foundation.UUID)
}
extension MeshAddress : Swift.Equatable {
  public static func == (lhs: MeshAddress, rhs: MeshAddress) -> Swift.Bool
  public static func != (lhs: MeshAddress, rhs: MeshAddress) -> Swift.Bool
}
extension MeshAddress : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension MeshAddress : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct GenericOnOffSet : AcknowledgedGenericMessage, TransactionMessage, TransitionMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let isOn: Swift.Bool
  public let transitionTime: TransitionTime?
  public let delay: Swift.UInt8?
  public init(_ isOn: Swift.Bool)
  public init(_ isOn: Swift.Bool, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public typealias MeshElement = Element
@_hasMissingDesignatedInitializers public class Element : Swift.Codable {
  public var name: Swift.String?
  public var index: Swift.UInt8 {
    get
  }
  public var location: Location {
    get
  }
  public var models: [Model]
  weak public var parentNode: Node? {
    get
  }
  public init(name: Swift.String? = nil, location: Location = .unknown, models: [Model])
  required public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
extension Element : Swift.Equatable {
  public static func == (lhs: Element, rhs: Element) -> Swift.Bool
  public static func != (lhs: Element, rhs: Element) -> Swift.Bool
}
extension Element : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Node {
  public var elementsCount: Swift.UInt8 {
    get
  }
  public var lastUnicastAddress: Address {
    get
  }
  public func hasAllocatedAddress(_ address: Address) -> Swift.Bool
  public func overlapsWithAddress(_ address: Address, elementsCount count: Swift.UInt8) -> Swift.Bool
}
@_hasMissingDesignatedInitializers open class Crypto {
  @objc deinit
}
extension Crypto {
  public static func calculateSalt(_ data: Foundation.Data) -> Foundation.Data
  public static func calculateCMAC(_ data: Foundation.Data, andKey key: Foundation.Data) -> Foundation.Data
  public static func calculateECB(_ data: Foundation.Data, andKey key: Foundation.Data) -> Foundation.Data
  public static func calculateCCM(_ data: Foundation.Data, withKey key: Foundation.Data, nonce: Foundation.Data, andMICSize size: Swift.UInt8, withAdditionalData aad: Foundation.Data?) -> Foundation.Data
  public static func calculateDecryptedCCM(_ data: Foundation.Data, withKey key: Foundation.Data, nonce: Foundation.Data, andMIC mic: Foundation.Data, withAdditionalData aad: Foundation.Data?) -> Foundation.Data?
  public static func calculateK1(withN N: Foundation.Data, salt: Foundation.Data, andP P: Foundation.Data) -> Foundation.Data
  public static func calculateK2(withN N: Foundation.Data, andP P: Foundation.Data) -> (nid: Swift.UInt8, encryptionKey: Foundation.Data, privacyKey: Foundation.Data)
  public static func calculateK3(withN N: Foundation.Data) -> Foundation.Data
  public static func calculateK4(withN N: Foundation.Data) -> Swift.UInt8
}
public protocol MeshNetworkDelegate : AnyObject {
  func meshNetworkManager(_ manager: MeshNetworkManager, didReceiveMessage message: any MeshMessage, sentFrom source: Address, to destination: Address)
  func meshNetworkManager(_ manager: MeshNetworkManager, didSendMessage message: any MeshMessage, from localElement: Element, to destination: Address)
  func meshNetworkManager(_ manager: MeshNetworkManager, failedToSendMessage message: any MeshMessage, from localElement: Element, to destination: Address, error: any Swift.Error)
  func meshNetworkManager(_ manager: MeshNetworkManager, ivIndexDidUpdate index: Swift.UInt32)
}
extension MeshNetworkDelegate {
  public func meshNetworkManager(_ manager: MeshNetworkManager, didSendMessage message: any MeshMessage, from localElement: Element, to destination: Address)
  public func meshNetworkManager(_ manager: MeshNetworkManager, failedToSendMessage message: any MeshMessage, from localElement: Element, to destination: Address, error: any Swift.Error)
}
extension Group {
  public var isUsed: Swift.Bool {
    get
  }
  public func isDirectChildOf(_ parent: Group) -> Swift.Bool
  public func isDirectParentOf(_ child: Group) -> Swift.Bool
  public func isChildOf(_ parent: Group) -> Swift.Bool
  public func isParentOf(_ child: Group) -> Swift.Bool
  public func setAsChildOf(_ parent: Group)
  public func setAsParentOf(_ child: Group)
}
@_inheritsConvenienceInitializers open class GattBearer : BaseGattProxyBearer<MeshProxyService>, MeshBearer {
  override public var supportedPduTypes: PduTypes {
    get
  }
  override public init(targetWithIdentifier uuid: Foundation.UUID)
  @objc deinit
}
extension Swift.Dictionary where Key == Swift.String, Value == Any {
  public var localName: Swift.String? {
    get
  }
  public var unprovisionedDeviceUUID: CoreBluetooth.CBUUID? {
    get
  }
  public var oobInformation: OobInformation? {
    get
  }
  public var networkId: Foundation.Data? {
    get
  }
  public var nodeIdentity: (hash: Foundation.Data, random: Foundation.Data)? {
    get
  }
}
@_inheritsConvenienceInitializers public class SceneRange : RangeObject, Swift.Codable {
  public var firstScene: SceneNumber {
    get
  }
  public var lastScene: SceneNumber {
    get
  }
  required convenience public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from lowerBound: Swift.UInt16, to upperBound: Swift.UInt16)
  required public init(_ range: Swift.ClosedRange<Swift.UInt16>)
  @objc deinit
}
public struct GenericLevelSet : AcknowledgedGenericMessage, TransactionMessage, TransitionMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let level: Swift.Int16
  public let transitionTime: TransitionTime?
  public let delay: Swift.UInt8?
  public init(level: Swift.Int16)
  public init(level: Swift.Int16, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLRangeStatus : GenericMessage, GenericStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: GenericMessageStatus
  public let minHue: Swift.UInt16
  public let maxHue: Swift.UInt16
  public let minSaturation: Swift.UInt16
  public let maxSaturation: Swift.UInt16
  public var hueRange: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public var saturationRange: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public init(report hueRange: Swift.ClosedRange<Swift.UInt16>, _ saturationRange: Swift.ClosedRange<Swift.UInt16>)
  public init(_ status: GenericMessageStatus, for request: LightHSLRangeSet)
  public init(_ status: GenericMessageStatus, for request: LightHSLRangeSetUnacknowledged)
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct ConfigAppKeyGet : AcknowledgedConfigMessage, ConfigNetKeyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: KeyIndex
  public init(networkKey: NetworkKey)
  public init?(parameters: Foundation.Data)
}
public protocol GenericMessage : StaticMeshMessage {
}
public protocol AcknowledgedGenericMessage : GenericMessage, StaticAcknowledgedMeshMessage {
}
extension Swift.Array where Element == any GenericMessage.Type {
  public func toMap() -> [Swift.UInt32 : any MeshMessage.Type]
}
public enum GenericMessageStatus : Swift.UInt8 {
  case success
  case cannotSetRangeMin
  case cannotSetRangeMax
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public protocol GenericStatusMessage : GenericMessage, StatusMessage {
  var status: GenericMessageStatus { get }
}
extension GenericStatusMessage {
  public var isSuccess: Swift.Bool {
    get
  }
  public var message: Swift.String {
    get
  }
}
extension GenericMessageStatus : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public enum SceneMessageStatus : Swift.UInt8 {
  case success
  case sceneRegisterFull
  case sceneNotFound
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public protocol SceneStatusMessage : GenericMessage, StatusMessage {
  var status: SceneMessageStatus { get }
}
extension SceneStatusMessage {
  public var isSuccess: Swift.Bool {
    get
  }
  public var message: Swift.String {
    get
  }
}
extension SceneMessageStatus : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct ConfigFriendGet : AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct ConfigSIGModelAppGet : AcknowledgedConfigMessage, ConfigModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let elementAddress: Address
  public let modelIdentifier: Swift.UInt16
  public init?(of model: Model)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLDefaultSet : AcknowledgedGenericMessage {
  public static var opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let hue: Swift.UInt16
  public let saturation: Swift.UInt16
  public init(lightness: Swift.UInt16, hue: Swift.UInt16, saturation: Swift.UInt16)
  public init?(parameters: Foundation.Data)
}
public struct ConfigModelPublicationStatus : ConfigAnyModelMessage, ConfigStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let elementAddress: Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public let publish: Publish
  public let status: ConfigMessageStatus
  public init(responseTo request: any ConfigAnyModelMessage, with publish: Publish?)
  public init(responseTo request: any ConfigAnyModelMessage, with status: ConfigMessageStatus)
  public init(confirm request: ConfigModelPublicationSet)
  public init(confirm request: ConfigModelPublicationVirtualAddressSet)
  public init?(parameters: Foundation.Data)
}
public enum PublicKey {
  case noOobPublicKey
  case oobPublicKey(key: Foundation.Data)
}
extension PublicKey : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct PublicKeyType : Swift.OptionSet {
  public let rawValue: Swift.UInt8
  public static let publicKeyOobInformationAvailable: PublicKeyType
  public init(rawValue: Swift.UInt8)
  public typealias ArrayLiteralElement = PublicKeyType
  public typealias Element = PublicKeyType
  public typealias RawValue = Swift.UInt8
}
extension PublicKeyType : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct ConfigModelSubscriptionAdd : AcknowledgedConfigMessage, ConfigAddressMessage, ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let address: Address
  public let elementAddress: Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public init?(group: Group, to model: Model)
  public init?(parameters: Foundation.Data)
}
public struct GenericDefaultTransitionTimeSetUnacknowledged : GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let transitionTime: TransitionTime
  public init(transitionTime: TransitionTime)
  public init?(parameters: Foundation.Data)
}
public enum DeviceProperty {
  case averageAmbientTemperatureInAPeriodOfDay
  case averageInputCurrent
  case averageInputVoltage
  case averageOutputCurrent
  case averageOutputVoltage
  case centerBeamIntensityAtFullPower
  case chromaticityTolerance
  case colorRenderingIndexR9
  case colorRenderingIndexRa
  case deviceAppearance
  case deviceCountryOfOrigin
  case deviceDateOfManufacture
  case deviceEnergyUseSinceTurnOn
  case deviceFirmwareRevision
  case deviceGlobalTradeItemNumber
  case deviceHardwareRevision
  case deviceManufacturerName
  case deviceModelNumber
  case deviceOperatingTemperatureRangeSpecification
  case deviceOperatingTemperatureStatisticalValues
  case deviceOverTemperatureEventStatistics
  case devicePowerRangeSpecification
  case deviceRuntimeSinceTurnOn
  case deviceRuntimeWarranty
  case deviceSerialNumber
  case deviceSoftwareRevision
  case deviceUnderTemperatureEventStatistics
  case indoorAmbientTemperatureStatisticalValues
  case initialCIE1931ChromaticityCoordinates
  case initialCorrelatedColorTemperature
  case initialLuminousFlux
  case initialPlanckianDistance
  case inputCurrentRangeSpecification
  case inputCurrentStatistics
  case inputOverCurrentEventStatistics
  case inputOverRippleVoltageEventStatistics
  case inputOverVoltageEventStatistics
  case inputUnderCurrentEventStatistics
  case inputUnderVoltageEventStatistics
  case inputVoltageRangeSpecification
  case inputVoltageRippleSpecification
  case inputVoltageStatistics
  case lightControlAmbientLuxLevelOn
  case lightControlAmbientLuxLevelProlong
  case lightControlAmbientLuxLevelStandby
  case lightControlLightnessOn
  case lightControlLightnessProlong
  case lightControlLightnessStandby
  case lightControlRegulatorAccuracy
  case lightControlRegulatorKid
  case lightControlRegulatorKiu
  case lightControlRegulatorKpd
  case lightControlRegulatorKpu
  case lightControlTimeFade
  case lightControlTimeFadeOn
  case lightControlTimeFadeStandbyAuto
  case lightControlTimeFadeStandbyManual
  case lightControlTimeOccupancyDelay
  case lightControlTimeProlong
  case lightControlTimeRunOn
  case lumenMaintenanceFactor
  case luminousEfficacy
  case luminousEnergySinceTurnOn
  case luminousExposure
  case luminousFluxRange
  case motionSensed
  case motionThreshold
  case openCircuitEventStatistics
  case outdoorStatisticalValues
  case outputCurrentRange
  case outputCurrentStatistics
  case outputRippleVoltageSpecification
  case outputVoltageRange
  case outputVoltageStatistics
  case overOutputRippleVoltageEventStatistics
  case peopleCount
  case presenceDetected
  case presentAmbientLightLevel
  case presentAmbientTemperature
  case presentCIE1931ChromaticityCoordinates
  case presentCorrelatedColorTemperature
  case presentDeviceInputPower
  case presentDeviceOperatingEfficiency
  case presentDeviceOperatingTemperature
  case presentIlluminance
  case presentIndoorAmbientTemperature
  case presentInputCurrent
  case presentInputRippleVoltage
  case presentInputVoltage
  case presentLuminousFlux
  case presentOutdoorAmbientTemperature
  case presentOutputCurrent
  case presentOutputVoltage
  case presentPlanckianDistance
  case presentRelativeOutputRippleVoltage
  case relativeDeviceEnergyUseInAPeriodOfDay
  case relativeDeviceRuntimeInAGenericLevelRange
  case relativeExposureTimeInAnIlluminanceRange
  case relativeRuntimeInACorrelatedColorTemperatureRange
  case relativeRuntimeInADeviceOperatingTemperatureRange
  case relativeRuntimeInAnInputCurrentRange
  case relativeRuntimeInAnInputVoltageRange
  case shortCircuitEventStatistics
  case timeSinceMotionSensed
  case timeSincePresenceDetected
  case totalDeviceEnergyUse
  case totalDeviceOffOnCycles
  case totalDevicePowerOnCycles
  case totalDevicePowerOnTime
  case totalDeviceRuntime
  case totalLightExposureTime
  case totalLuminousEnergy
  case desiredAmbientTemperature
  case preciseTotalDeviceEnergyUse
  case powerFactor
  case sensorGain
  case precisePresentAmbientTemperature
  case presentAmbientRelativeHumidity
  case presentAmbientCarbonDioxideConcentration
  case presentAmbientVolatileOrganicCompoundsConcentration
  case presentAmbientNoise
  case activeEnergyLoadside
  case activePowerLoadside
  case airPressure
  case apparentEnergy
  case apparentPower
  case apparentWindDirection
  case apparentWindSpeed
  case dewPoint
  case externalSupplyVoltage
  case externalSupplyVoltageFrequency
  case gustFactor
  case heatIndex
  case lightDistribution
  case lightSourceCurrent
  case lightSourceOnTimeNotResettable
  case lightSourceOnTimeResettable
  case lightSourceOpenCircuitStatistics
  case lightSourceOverallFailuresStatistics
  case lightSourceShortCircuitStatistics
  case lightSourceStartCounterResettable
  case lightSourceTemperature
  case lightSourceThermalDeratingStatistics
  case lightSourceThermalShutdownStatistics
  case lightSourceTotalPowerOnCycles
  case lightSourceVoltage
  case luminaireColor
  case luminaireIdentificationNumber
  case luminaireManufacturerGTIN
  case luminaireNominalInputPower
  case luminaireNominalMaximumACMainsVoltage
  case luminaireNominalMinimumACMainsVoltage
  case luminairePowerAtMinimumDimLevel
  case luminaireTimeOfManufacture
  case magneticDeclination
  case magneticFluxDensity2D
  case magneticFluxDensity3D
  case nominalLightOutput
  case overallFailureCondition
  case pollenConcentration
  case presentIndoorRelativeHumidity
  case presentOutdoorRelativeHumidity
  case pressure
  case rainfall
  case ratedMedianUsefulLifeOfLuminaire
  case ratedMedianUsefulLightSourceStarts
  case referenceTemperature
  case totalDeviceStarts
  case trueWindDirection
  case trueWindSpeed
  case uVIndex
  case windChill
  case lightSourceType
  case luminaireIdentificationString
  case outputPowerLimitation
  case thermalDerating
  case outputCurrentPercent
  case unknown(Swift.UInt16)
  public var id: Swift.UInt16 {
    get
  }
}
extension DeviceProperty : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public enum DevicePropertyCharacteristic : Swift.Equatable {
  case bool(Swift.Bool)
  case count16(Swift.UInt16?)
  case count24(Swift.UInt32?)
  case coefficient(Swift.Float32)
  case dateUTC(Foundation.Date?)
  case electricCurrent(Foundation.Decimal?)
  case energy32(Foundation.Decimal?)
  case fixedString8(Swift.String)
  case fixedString16(Swift.String)
  case fixedString24(Swift.String)
  case fixedString36(Swift.String)
  case fixedString64(Swift.String)
  case humidity(Foundation.Decimal?)
  case illuminance(Foundation.Decimal?)
  case percentage8(Foundation.Decimal?)
  case perceivedLightness(Swift.UInt16)
  case power(Foundation.Decimal?)
  case pressure(Foundation.Decimal)
  case temperature(Foundation.Decimal?)
  case temperature8(Foundation.Decimal?)
  case timeHour24(Swift.UInt32?)
  case timeMillisecond24(Swift.UInt32?)
  case timeSecond16(Swift.UInt16?)
  case timeSecond32(Swift.UInt32?)
  case other(Foundation.Data)
  public static func == (a: DevicePropertyCharacteristic, b: DevicePropertyCharacteristic) -> Swift.Bool
}
extension DevicePropertyCharacteristic : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct ConfigKeyRefreshPhaseGet : AcknowledgedConfigMessage, ConfigNetKeyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: KeyIndex
  public init(networkKey: NetworkKey)
  public init?(parameters: Foundation.Data)
}
extension Swift.Array where Element == NetworkKey {
  public subscript(networkId: Foundation.Data) -> NetworkKey? {
    get
  }
  public subscript(keyIndex: KeyIndex) -> NetworkKey? {
    get
  }
  public var primaryKey: NetworkKey? {
    get
  }
  public func knownTo(node: Node) -> [NetworkKey]
  public func notKnownTo(node: Node) -> [NetworkKey]
}
public struct GenericBatteryGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
extension Provisioner {
  public var isValid: Swift.Bool {
    get
  }
  public func allocateUnicastAddressRange(_ range: AddressRange) throws
  public func allocateUnicastAddressRanges(_ ranges: [AddressRange]) throws
  public func allocateGroupAddressRange(_ range: AddressRange) throws
  public func allocateGroupAddressRanges(_ ranges: [AddressRange]) throws
  public func allocateSceneRange(_ range: SceneRange) throws
  public func allocateSceneRanges(_ ranges: [SceneRange]) throws
  public func deallocateUnicastAddressRange(_ range: AddressRange)
  public func deallocateGroupAddressRange(_ range: AddressRange)
  public func deallocateSceneRange(_ range: SceneRange)
  public func isAddressInAllocatedRange(_ address: Address, elementCount count: Swift.UInt8) -> Swift.Bool
  public func isSceneInAllocatedRange(_ scene: SceneNumber) -> Swift.Bool
  public var scenes: [Scene] {
    get
  }
  public func maxElementCount(for address: Address) -> Swift.Int
  public func hasOverlappingRanges(with provisioner: Provisioner) -> Swift.Bool
  public func hasOverlappingUnicastRanges(with provisioner: Provisioner) -> Swift.Bool
  public func hasOverlappingGroupRanges(with provisioner: Provisioner) -> Swift.Bool
  public func hasOverlappingSceneRanges(with provisioner: Provisioner) -> Swift.Bool
}
public struct ConfigHeartbeatSubscriptionGet : AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct ConfigNetKeyUpdate : AcknowledgedConfigMessage, ConfigNetKeyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: KeyIndex
  public let key: Foundation.Data
  public init(networkKey: NetworkKey)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLHueStatus : GenericMessage, TransitionStatusMessage {
  public static var opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let hue: Swift.UInt16
  public let targetHue: Swift.UInt16?
  public let remainingTime: TransitionTime?
  public init(hue: Swift.UInt16)
  public init(hue: Swift.UInt16, targetHue: Swift.UInt16, remainingTime: TransitionTime)
  public init?(parameters: Foundation.Data)
}
public struct SceneRegisterStatus : GenericMessage, SceneStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: SceneMessageStatus
  public let currentScene: SceneNumber
  public let scenes: [SceneNumber]
  public var isSceneActive: Swift.Bool {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public init(report currentScene: SceneNumber, and scenes: [SceneNumber])
  public init(report currentScene: SceneNumber, and scenes: [SceneNumber], with status: SceneMessageStatus)
  public init?(parameters: Foundation.Data)
}
public struct LightLCPropertyGet : AcknowledgedSensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public let property: DeviceProperty
  public var parameters: Foundation.Data? {
    get
  }
  public init(_ property: DeviceProperty)
  public init?(parameters: Foundation.Data)
}
public struct MessageHandle {
  public let opCode: Swift.UInt32
  public let source: Address
  public let destination: Address
  public func cancel()
}
public struct LightLCPropertySet : AcknowledgedSensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public let property: DeviceProperty
  public let propertyValue: DevicePropertyCharacteristic
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: DeviceProperty, value: DevicePropertyCharacteristic)
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessSetUnacknowledged : GenericMessage, TransactionMessage, TransitionMessage {
  public static var opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let transitionTime: TransitionTime?
  public let delay: Swift.UInt8?
  public init(lightness: Swift.UInt16)
  public init(lightness: Swift.UInt16, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct ConfigKeyRefreshPhaseSet : AcknowledgedConfigMessage, ConfigNetKeyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: KeyIndex
  public let transition: KeyRefreshPhaseTransition
  public init(networkKey: NetworkKey, transition: KeyRefreshPhaseTransition)
  public init?(parameters: Foundation.Data)
}
extension MeshNetwork {
  public func add(scene: SceneNumber, name: Swift.String) throws
  public func remove(scene: SceneNumber) throws
  public func nodes(registeredTo scene: SceneNumber) -> [Node]
  public func nextAvailableScene(for provisioner: Provisioner) -> SceneNumber?
  public func nextAvailableScene() -> SceneNumber?
}
public struct AddAddressesToFilter : StaticAcknowledgedProxyConfigurationMessage {
  public static let opCode: Swift.UInt8
  public static let responseType: any StaticProxyConfigurationMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let addresses: Swift.Set<Address>
  public init(_ addresses: Swift.Set<Address>)
  public init?(parameters: Foundation.Data)
}
public enum Security : Swift.String, Swift.Codable {
  case insecure
  case secure
  public init(from decoder: any Swift.Decoder) throws
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension Security : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct SceneDelete : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let scene: SceneNumber
  public init(_ scene: SceneNumber)
  public init?(parameters: Foundation.Data)
}
public struct LightCTLDefaultSetUnacknowledged : GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let temperature: Swift.UInt16
  public let deltaUV: Swift.Int16
  public init(lightness: Swift.UInt16, temperature: Swift.UInt16, deltaUV: Swift.Int16)
  public init?(parameters: Foundation.Data)
}
public struct ConfigFriendSet : AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let state: NodeFeatureState
  public init(enable: Swift.Bool)
  public init?(parameters: Foundation.Data)
}
public struct SensorSettingSetUnacknowledged : SensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public let property: DeviceProperty
  public let settingProperty: DeviceProperty
  public let settingValue: DevicePropertyCharacteristic
  public var parameters: Foundation.Data? {
    get
  }
  public init(_ setting: DeviceProperty, of property: DeviceProperty, to value: DevicePropertyCharacteristic)
  public init?(parameters: Foundation.Data)
}
public typealias SensorValue = (property: DeviceProperty, value: DevicePropertyCharacteristic)
public struct SensorStatus : SensorMessage {
  public static let opCode: Swift.UInt32
  public let values: [SensorValue]
  public var parameters: Foundation.Data? {
    get
  }
  public init(_ value: SensorValue)
  public init(_ values: [SensorValue])
  public init?(parameters: Foundation.Data)
}
public struct GenericMoveSetUnacknowledged : GenericMessage, TransactionMessage, TransitionMessage {
  public static let opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let deltaLevel: Swift.Int16
  public let transitionTime: TransitionTime?
  public let delay: Swift.UInt8?
  public init(deltaLevel: Swift.Int16)
  public init(deltaLevel: Swift.Int16, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
@_hasMissingDesignatedInitializers public class HeartbeatSubscription : Swift.Codable {
  final public let source: Address
  final public let destination: Address
  required public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
public struct ConfigModelAppBind : AcknowledgedConfigMessage, ConfigAppKeyMessage, ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let applicationKeyIndex: KeyIndex
  public let elementAddress: Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public init?(applicationKey: ApplicationKey, to model: Model)
  public init?(parameters: Foundation.Data)
}
@_hasMissingDesignatedInitializers public class NetworkKey : Key, Swift.Codable {
  public var timestamp: Foundation.Date {
    get
  }
  public var name: Swift.String
  public var index: KeyIndex {
    get
  }
  public var phase: KeyRefreshPhase {
    get
  }
  public var key: Foundation.Data {
    get
  }
  public var oldKey: Foundation.Data? {
    get
  }
  public var minSecurity: Security {
    get
  }
  public var networkId: Foundation.Data! {
    get
  }
  public var oldNetworkId: Foundation.Data? {
    get
  }
  required public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
extension NetworkKey : Swift.Equatable {
  public static func == (lhs: NetworkKey, rhs: NetworkKey) -> Swift.Bool
  public static func != (lhs: NetworkKey, rhs: NetworkKey) -> Swift.Bool
}
extension NetworkKey : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct ConfigHeartbeatPublicationStatus : ConfigMessage, ConfigStatusMessage, ConfigNetKeyMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: ConfigMessageStatus
  public let networkKeyIndex: KeyIndex
  public let destination: Address
  public let countLog: Swift.UInt8
  public var count: RemainingHeartbeatPublicationCount {
    get
  }
  public let periodLog: Swift.UInt8
  public var period: Swift.UInt16 {
    get
  }
  public let ttl: Swift.UInt8
  public let features: NodeFeatures
  public var isEnabled: Swift.Bool {
    get
  }
  public var isPeriodicPublicationEnabled: Swift.Bool {
    get
  }
  public var isFeatureTriggeredPublishingEnabled: Swift.Bool {
    get
  }
  public init(_ publication: HeartbeatPublication?)
  public init(responseTo request: ConfigHeartbeatPublicationSet, with status: ConfigMessageStatus)
  public init(confirm request: ConfigHeartbeatPublicationSet)
  public init?(parameters: Foundation.Data)
}
public struct GenericOnOffStatus : GenericMessage, TransitionStatusMessage {
  public static var opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let isOn: Swift.Bool
  public let targetState: Swift.Bool?
  public let remainingTime: TransitionTime?
  public init(_ isOn: Swift.Bool)
  public init(_ isOn: Swift.Bool, targetState: Swift.Bool, remainingTime: TransitionTime)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessDefaultStatus : GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public init(lightness: Swift.UInt16)
  public init?(parameters: Foundation.Data)
}
public struct GenericLevelStatus : GenericMessage, TransitionStatusMessage {
  public static var opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let level: Swift.Int16
  public let targetLevel: Swift.Int16?
  public let remainingTime: TransitionTime?
  public init(level: Swift.Int16)
  public init(level: Swift.Int16, targetLevel: Swift.Int16, remainingTime: TransitionTime)
  public init?(parameters: Foundation.Data)
}
public struct ConfigCompositionDataGet : AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let page: Swift.UInt8
  public init(page: Swift.UInt8 = 0)
  public init?(parameters: Foundation.Data)
}
public protocol GattBearerDelegate : BearerDelegate {
  func bearerDidConnect(_ bearer: any Bearer)
  func bearerDidDiscoverServices(_ bearer: any Bearer)
  func bearer(_ bearer: any Bearer, didReadRSSI RSSI: Foundation.NSNumber)
  func bearerDidSwitchedToProxy(_ bearer: any Bearer)
}
extension GattBearerDelegate {
  public func bearerDidConnect(_ bearer: any Bearer)
  public func bearerDidDiscoverServices(_ bearer: any Bearer)
  public func bearer(_ bearer: any Bearer, didReadRSSI RSSI: Foundation.NSNumber)
  public func bearerDidSwitchedToProxy(_ bearer: any Bearer)
}
public struct GenericOnOffGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessStatus : GenericMessage, TransitionStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let targetLightness: Swift.UInt16?
  public let remainingTime: TransitionTime?
  public init(lightness: Swift.UInt16)
  public init(lightness: Swift.UInt16, targetLightness: Swift.UInt16, remainingTime: TransitionTime)
  public init?(parameters: Foundation.Data)
}
public enum Algorithm {
  case fipsP256EllipticCurve
  public static func == (a: Algorithm, b: Algorithm) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Algorithm : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct Algorithms : Swift.OptionSet {
  public let rawValue: Swift.UInt16
  public static let fipsP256EllipticCurve: Algorithms
  public init(rawValue: Swift.UInt16)
  public typealias ArrayLiteralElement = Algorithms
  public typealias Element = Algorithms
  public typealias RawValue = Swift.UInt16
}
extension Algorithms : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct LightLCOccupancyModeGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct ConfigGATTProxyGet : AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct ConfigNodeReset : AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
@_inheritsConvenienceInitializers public class AddressRange : RangeObject, Swift.Codable {
  public var lowAddress: Address {
    get
  }
  public var highAddress: Address {
    get
  }
  required convenience public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from lowerBound: Swift.UInt16, to upperBound: Swift.UInt16)
  required public init(_ range: Swift.ClosedRange<Swift.UInt16>)
  @objc deinit
}
public struct LightCTLSetUnacknowledged : GenericMessage, TransactionMessage, TransitionMessage {
  public static let opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let temperature: Swift.UInt16
  public let deltaUV: Swift.Int16
  public var transitionTime: TransitionTime?
  public var delay: Swift.UInt8?
  public init(lightness: Swift.UInt16, temperature: Swift.UInt16, deltaUV: Swift.Int16)
  public init(lightness: Swift.UInt16, temperature: Swift.UInt16, deltaUV: Swift.Int16, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct ConfigModelSubscriptionVirtualAddressAdd : AcknowledgedConfigMessage, ConfigVirtualLabelMessage, ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let virtualLabel: Foundation.UUID
  public let elementAddress: Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public init?(group: Group, to model: Model)
  public init?(parameters: Foundation.Data)
}
extension MeshNetwork {
  public func isRangeAvailableForAllocation(_ range: AddressRange) -> Swift.Bool
  public func areRangesAvailableForAllocation(_ ranges: [AddressRange]) -> Swift.Bool
  public func isRangeAvailableForAllocation(_ range: SceneRange) -> Swift.Bool
  public func areRangesAvailableForAllocation(_ ranges: [SceneRange]) -> Swift.Bool
  public func isRange(_ range: AddressRange, availableForAllocationTo provisioner: Provisioner) -> Swift.Bool
  public func areRanges(_ ranges: [AddressRange], availableForAllocationTo provisioner: Provisioner) -> Swift.Bool
  public func isRange(_ range: SceneRange, availableForAllocationTo provisioner: Provisioner) -> Swift.Bool
  public func areRanges(_ ranges: [SceneRange], availableForAllocationTo provisioner: Provisioner) -> Swift.Bool
  public func nextAvailableUnicastAddressRange(ofSize size: Swift.UInt16 = .maxUnicastAddress - .minUnicastAddress + 1) -> AddressRange?
  public func nextAvailableGroupAddressRange(ofSize size: Swift.UInt16 = .maxGroupAddress - .minGroupAddress + 1) -> AddressRange?
  public func nextAvailableSceneRange(ofSize size: Swift.UInt16 = .maxScene - .minScene + 1) -> SceneRange?
}
public struct GenericPowerLastStatus : GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let power: Swift.UInt16
  public init(power: Swift.UInt16)
  public init?(parameters: Foundation.Data)
}
extension Scene {
  public var nodes: [Node] {
    get
  }
}
public struct ConfigModelPublicationGet : AcknowledgedConfigMessage, ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let elementAddress: Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public init?(for model: Model)
  public init?(parameters: Foundation.Data)
}
public struct SceneRegisterGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct ConfigAppKeyUpdate : AcknowledgedConfigMessage, ConfigNetAndAppKeyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: KeyIndex
  public let applicationKeyIndex: KeyIndex
  public let key: Foundation.Data
  public init(applicationKey: ApplicationKey)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLStatus : GenericMessage, TransitionStatusMessage {
  public static var opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let hue: Swift.UInt16
  public let saturation: Swift.UInt16
  public let remainingTime: TransitionTime?
  public init(lightness: Swift.UInt16, hue: Swift.UInt16, saturation: Swift.UInt16)
  public init(lightness: Swift.UInt16, hue: Swift.UInt16, saturation: Swift.UInt16, remainingTime: TransitionTime)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLSaturationSetUnacknowledged : GenericMessage, TransactionMessage, TransitionMessage {
  public static var opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let saturation: Swift.UInt16
  public let transitionTime: TransitionTime?
  public let delay: Swift.UInt8?
  public init(saturation: Swift.UInt16)
  public init(saturation: Swift.UInt16, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct GenericPowerLevelSet : AcknowledgedGenericMessage, TransactionMessage, TransitionMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let power: Swift.UInt16
  public let transitionTime: TransitionTime?
  public let delay: Swift.UInt8?
  public init(power: Swift.UInt16)
  public init(power: Swift.UInt16, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct LightCTLDefaultSet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let temperature: Swift.UInt16
  public let deltaUV: Swift.Int16
  public init(lightness: Swift.UInt16, temperature: Swift.UInt16, deltaUV: Swift.Int16)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLRangeGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct GenericMoveSet : AcknowledgedGenericMessage, TransactionMessage, TransitionMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let deltaLevel: Swift.Int16
  public let transitionTime: TransitionTime?
  public let delay: Swift.UInt8?
  public init(deltaLevel: Swift.Int16)
  public init(deltaLevel: Swift.Int16, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
extension Model {
  public var name: Swift.String? {
    get
  }
}
public struct ConfigModelSubscriptionVirtualAddressDelete : AcknowledgedConfigMessage, ConfigVirtualLabelMessage, ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let virtualLabel: Foundation.UUID
  public let elementAddress: Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public init?(group: Group, from model: Model)
  public init?(parameters: Foundation.Data)
}
public struct GenericPowerRangeSet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let range: Swift.ClosedRange<Swift.UInt16>
  public init(range: Swift.ClosedRange<Swift.UInt16>)
  public init?(parameters: Foundation.Data)
}
@objc @_inheritsConvenienceInitializers @objcMembers open class MeshSDK : ObjectiveC.NSObject {
  @objc public static let sharedInstance: MeshSDK
  @objc public var delegate: (any MXMeshDelegate)?
  @objc public var isSegmented: Swift.Bool
  @objc public var nextUnicastAddress: Swift.UInt16
  @objc public var proxyRSSI: Swift.Int
  @objc public var meshMaxConnections: Swift.Int
  public var meshNetworkManager: MeshNetworkManager
  public typealias MXMeshMessageCallBack = ([Swift.String : Any]) -> ()
  public typealias MXMeshResultCallBack = (Swift.Bool) -> ()
  @objc public var meshMessageDict: [Swift.String : Any]
  @objc public var meshGattRssiback: ((_ peripheral: CoreBluetooth.CBPeripheral, _ rssi: Swift.Int) -> ())?
  @objc public var connectedDeviceMac: Swift.String? {
    @objc get
  }
  @objc override dynamic public init()
  @objc public func setup(config: [Swift.String : Any]? = nil, provisioningServiceConfig: [Swift.String : Swift.String]? = nil, proxyServiceConfig: [Swift.String : Swift.String]? = nil, networkConfig: [Swift.String : Any]? = nil)
  @objc deinit
  @objc public func getNextTid() -> Swift.String
}
extension MeshSDK {
  @objc dynamic public func exportMeshNetwork(callback: (Swift.String) -> ())
  @objc dynamic public func importMeshNetwork(jsonString: Swift.String, callback: (Swift.Bool) -> ())
  @objc dynamic public func importMeshNetworkConfig(jsonString: Swift.String, callback: (Swift.Bool) -> ())
  @objc dynamic public func resetProvisionerUnicastAddress(address: Swift.UInt16)
  @objc dynamic public func setMeshNetworkSequence(seq: Swift.UInt32, updateInterval: Swift.UInt32)
  @objc dynamic public func getMeshNetworkSequence() -> Swift.UInt32
  @objc dynamic public func setMeshNetworkIvIndex(index: Swift.UInt32)
}
extension MeshSDK {
  @objc dynamic public func disconnect(mac: Swift.String? = nil)
  @objc dynamic public func connect(mac: Swift.String? = nil)
  @objc dynamic public func addMeshProxy(peripheral: CoreBluetooth.CBPeripheral, mac: Swift.String)
  @objc dynamic public func switchProxy(mac: Swift.String)
  @objc dynamic public func getCurrentProxyMac() -> Swift.String?
  @objc dynamic public func isConnected() -> Swift.Bool
  @objc dynamic public func getNextUnicastAddress() -> Swift.UInt16
  @objc dynamic public func readCurrentGattRssi(callback: @escaping (_ peripheral: CoreBluetooth.CBPeripheral, _ rssi: Swift.Int) -> ())
}
extension MeshSDK : LoggerDelegate {
  public func log(message: Swift.String, ofCategory category: LogCategory, withLevel level: LogLevel)
}
public struct ConfigGATTProxySet : AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let state: NodeFeatureState
  public init(enable: Swift.Bool)
  public init?(parameters: Foundation.Data)
}
public struct CompanyIdentifier {
  public static func name(for id: Swift.UInt16) -> Swift.String?
}
public struct GenericOnOffSetUnacknowledged : GenericMessage, TransactionMessage, TransitionMessage {
  public static let opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let isOn: Swift.Bool
  public let transitionTime: TransitionTime?
  public let delay: Swift.UInt8?
  public init(_ isOn: Swift.Bool)
  public init(_ isOn: Swift.Bool, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct ConfigNodeIdentityStatus : ConfigNetKeyMessage, ConfigStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: KeyIndex
  public let identity: NodeIdentity
  public let status: ConfigMessageStatus
  public init(report identity: NodeIdentity, for networkKey: NetworkKey, with status: ConfigMessageStatus)
  public init(responseTo request: any ConfigNetKeyMessage)
  public init?(parameters: Foundation.Data)
}
public protocol ConfigMessage : StaticMeshMessage {
}
public protocol AcknowledgedConfigMessage : ConfigMessage, StaticAcknowledgedMeshMessage {
}
public enum ConfigMessageStatus : Swift.UInt8 {
  case success
  case invalidAddress
  case invalidModel
  case invalidAppKeyIndex
  case invalidNetKeyIndex
  case insufficientResources
  case keyIndexAlreadyStored
  case invalidPublishParameters
  case notASubscribeModel
  case storageFailure
  case featureNotSupported
  case cannotUpdate
  case cannotRemove
  case cannotBind
  case temporarilyUnableToChangeState
  case cannotSet
  case unspecifiedError
  case invalidBinding
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public protocol ConfigStatusMessage : ConfigMessage, StatusMessage {
  var status: ConfigMessageStatus { get }
}
public protocol ConfigNetKeyMessage : ConfigMessage {
  var networkKeyIndex: KeyIndex { get }
}
public protocol ConfigAppKeyMessage : ConfigMessage {
  var applicationKeyIndex: KeyIndex { get }
}
public protocol ConfigNetAndAppKeyMessage : ConfigAppKeyMessage, ConfigNetKeyMessage {
}
public protocol ConfigElementMessage : ConfigMessage {
  var elementAddress: Address { get }
}
public protocol ConfigModelMessage : ConfigElementMessage {
  var modelIdentifier: Swift.UInt16 { get }
  var modelId: Swift.UInt32 { get }
}
public protocol ConfigAnyModelMessage : ConfigModelMessage {
  var companyIdentifier: Swift.UInt16? { get }
}
public protocol ConfigVendorModelMessage : ConfigModelMessage {
  var companyIdentifier: Swift.UInt16 { get }
}
public protocol ConfigAddressMessage : ConfigMessage {
  var address: Address { get }
}
public protocol ConfigVirtualLabelMessage : ConfigMessage {
  var virtualLabel: Foundation.UUID { get }
}
public protocol ConfigModelAppList : ConfigModelMessage, ConfigStatusMessage {
  var applicationKeyIndexes: [KeyIndex] { get }
}
public protocol ConfigModelSubscriptionList : ConfigModelMessage, ConfigStatusMessage {
  var addresses: [Address] { get }
}
@frozen public enum RemainingHeartbeatPublicationCount {
  case disabled
  case indefinitely
  case exact(_: Swift.UInt16)
  case range(_: Swift.ClosedRange<Swift.UInt16>)
  case invalid(countLog: Swift.UInt8)
}
@frozen public enum RemainingHeartbeatSubscriptionPeriod {
  case disabled
  case exact(_: Swift.UInt16)
  case range(_: Swift.ClosedRange<Swift.UInt16>)
  case invalid(periodLog: Swift.UInt8)
}
@frozen public enum HeartbeatSubscriptionCount {
  case exact(_: Swift.UInt16)
  case range(_: Swift.ClosedRange<Swift.UInt16>)
  case reallyALot
  case invalid(countLog: Swift.UInt8)
}
extension ConfigStatusMessage {
  public var isSuccess: Swift.Bool {
    get
  }
  public var message: Swift.String {
    get
  }
}
extension ConfigModelMessage {
  public var modelId: Swift.UInt32 {
    get
  }
}
extension ConfigAnyModelMessage {
  public var isBluetoothSIGAssigned: Swift.Bool {
    get
  }
  public var modelId: Swift.UInt32 {
    get
  }
}
extension ConfigVendorModelMessage {
  public var modelId: Swift.UInt32 {
    get
  }
}
extension Swift.Array where Element == any ConfigMessage.Type {
  public func toMap() -> [Swift.UInt32 : any MeshMessage.Type]
}
extension ConfigMessageStatus : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension RemainingHeartbeatPublicationCount : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension RemainingHeartbeatSubscriptionPeriod : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension HeartbeatSubscriptionCount : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct SensorDescriptorGet : AcknowledgedSensorMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public let property: DeviceProperty?
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: DeviceProperty? = nil)
  public init?(parameters: Foundation.Data)
}
public struct ConfigHeartbeatSubscriptionStatus : ConfigMessage, ConfigStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: ConfigMessageStatus
  public let source: Address
  public let destination: Address
  public let periodLog: Swift.UInt8
  public var period: RemainingHeartbeatSubscriptionPeriod {
    get
  }
  public let countLog: Swift.UInt8
  public var count: HeartbeatSubscriptionCount {
    get
  }
  public let minHops: Swift.UInt8
  public let maxHops: Swift.UInt8
  public var isEnabled: Swift.Bool {
    get
  }
  public var isComplete: Swift.Bool {
    get
  }
  public init(_ subscription: HeartbeatSubscription?)
  public init(cancel subscription: HeartbeatSubscription)
  public init(responseTo request: ConfigHeartbeatSubscriptionSet, with status: ConfigMessageStatus)
  public init?(parameters: Foundation.Data)
}
public struct LightLCLightOnOffStatus : GenericMessage, TransitionStatusMessage {
  public static var opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let isOn: Swift.Bool
  public let targetState: Swift.Bool?
  public let remainingTime: TransitionTime?
  public init(_ isOn: Swift.Bool)
  public init(_ isOn: Swift.Bool, targetState: Swift.Bool, remainingTime: TransitionTime)
  public init?(parameters: Foundation.Data)
}
public struct LightCTLTemperatureRangeStatus : GenericMessage, GenericStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: GenericMessageStatus
  public let min: Swift.UInt16
  public let max: Swift.UInt16
  public var range: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public init(report range: Swift.ClosedRange<Swift.UInt16>)
  public init(_ status: GenericMessageStatus, for request: LightCTLTemperatureRangeSet)
  public init(_ status: GenericMessageStatus, for request: LightCTLTemperatureRangeSetUnacknowledged)
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessLastStatus : GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public init(lightness: Swift.UInt16)
  public init?(parameters: Foundation.Data)
}
extension MeshSDK {
  @objc dynamic public func getGATTProxyStatus(uuid: Swift.String, callback: @escaping MXMeshMessageCallBack)
  @objc dynamic public func getCompositionData(uuid: Swift.String, callback: @escaping MXMeshResultCallBack)
  @objc dynamic public func getTtl(uuid: Swift.String, callback: @escaping MXMeshResultCallBack)
  @objc dynamic public func resetNode(uuid: Swift.String, callback: MeshSDK.MXMeshResultCallBack? = nil)
}
public enum PduType : Swift.UInt8 {
  case networkPdu
  case meshBeacon
  case proxyConfiguration
  case provisioningPdu
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct PduTypes : Swift.OptionSet {
  public let rawValue: Swift.UInt8
  public static let networkPdu: PduTypes
  public static let meshBeacon: PduTypes
  public static let proxyConfiguration: PduTypes
  public static let provisioningPdu: PduTypes
  public init(rawValue: Swift.UInt8)
  public typealias ArrayLiteralElement = PduTypes
  public typealias Element = PduTypes
  public typealias RawValue = Swift.UInt8
}
public protocol Transmitter : AnyObject {
  func send(_ data: Foundation.Data, ofType type: PduType) throws
}
public protocol Bearer : Transmitter {
  var logger: (any LoggerDelegate)? { get set }
  var name: Swift.String? { get }
  var identifier: Foundation.UUID { get }
  var mac: Swift.String? { get set }
  var delegate: (any BearerDelegate)? { get set }
  var dataDelegate: (any BearerDataDelegate)? { get set }
  var supportedPduTypes: PduTypes { get }
  var isOpen: Swift.Bool { get }
  func open()
  func close()
}
extension Bearer {
  public func supports(_ pduType: PduType) -> Swift.Bool
}
public protocol MeshBearer : Bearer {
}
public protocol ProvisioningBearer : Bearer {
}
public protocol MXProvisioningBearer : MeshBearer, ProvisioningBearer {
  func switchToProxyBearer() -> Swift.Bool
}
public struct GenericDefaultTransitionTimeSet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let transitionTime: TransitionTime
  public init(transitionTime: TransitionTime)
  public init?(parameters: Foundation.Data)
}
public struct GenericLevelGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct GenericOnPowerUpSet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let state: OnPowerUp
  public init(state: OnPowerUp)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLDefaultSetUnacknowledged : GenericMessage {
  public static var opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let hue: Swift.UInt16
  public let saturation: Swift.UInt16
  public init(lightness: Swift.UInt16, hue: Swift.UInt16, saturation: Swift.UInt16)
  public init?(parameters: Foundation.Data)
}
extension Element {
  public var unicastAddress: Address {
    get
  }
  public var isPrimary: Swift.Bool {
    get
  }
}
public struct ConfigDefaultTtlSet : AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let ttl: Swift.UInt8
  public init(ttl: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public typealias SceneNumber = Swift.UInt16
extension Swift.UInt16 {
  public static let invalidScene: SceneNumber
  public static let minScene: SceneNumber
  public static let maxScene: SceneNumber
}
extension Swift.UInt16 {
  public var isValidSceneNumber: Swift.Bool {
    get
  }
}
@objc @_inheritsConvenienceInitializers @objcMembers open class MXMeshDeviceScan : ObjectiveC.NSObject, CoreBluetooth.CBCentralManagerDelegate {
  @objc public static let shared: MXMeshDeviceScan
  public typealias DisposedScanResultReadableCallback = ([[Swift.String : Any]]) -> ()
  @objc override dynamic public init()
  @objc public func scanDevice(mac: Swift.String?, timeout: Swift.Int, callback: @escaping MXMeshDeviceScan.DisposedScanResultReadableCallback)
  @objc public func stopScan()
  @objc public func centralManager(_ central: CoreBluetooth.CBCentralManager, didDiscover peripheral: CoreBluetooth.CBPeripheral, advertisementData: [Swift.String : Any], rssi RSSI: Foundation.NSNumber)
  @objc public func centralManagerDidUpdateState(_ central: CoreBluetooth.CBCentralManager)
  @objc deinit
}
public struct SensorCadenceGet : AcknowledgedSensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public let property: DeviceProperty
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: DeviceProperty)
  public init?(parameters: Foundation.Data)
}
public struct LightCTLTemperatureStatus : GenericMessage, TransitionStatusMessage {
  public static var opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let temperature: Swift.UInt16
  public let deltaUV: Swift.Int16
  public let targetTemperature: Swift.UInt16?
  public let targetDeltaUV: Swift.Int16?
  public let remainingTime: TransitionTime?
  public init(temperature: Swift.UInt16, deltaUV: Swift.Int16)
  public init(temperature: Swift.UInt16, deltaUV: Swift.Int16, targetTemperature: Swift.UInt16, targetDeltaUV: Swift.Int16, remainingTime: TransitionTime)
  public init?(parameters: Foundation.Data)
}
extension ApplicationKey {
  public func isUsed(in meshNetwork: MeshNetwork) -> Swift.Bool
}
public struct LightCTLDefaultStatus : GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let temperature: Swift.UInt16
  public let deltaUV: Swift.Int16
  public init(lightness: Swift.UInt16, temperature: Swift.UInt16, deltaUV: Swift.Int16)
  public init?(parameters: Foundation.Data)
}
public struct SensorSettingSet : AcknowledgedSensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public let property: DeviceProperty
  public let settingProperty: DeviceProperty
  public let settingValue: DevicePropertyCharacteristic
  public var parameters: Foundation.Data? {
    get
  }
  public init(_ setting: DeviceProperty, of property: DeviceProperty, to value: DevicePropertyCharacteristic)
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessDefaultSetUnacknowledged : GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public init(lightness: Swift.UInt16)
  public init?(parameters: Foundation.Data)
}
public struct LightCTLTemperatureSet : AcknowledgedGenericMessage, TransactionMessage, TransitionMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let temperature: Swift.UInt16
  public let deltaUV: Swift.Int16
  public var transitionTime: TransitionTime?
  public var delay: Swift.UInt8?
  public init(temperature: Swift.UInt16, deltaUV: Swift.Int16)
  public init(temperature: Swift.UInt16, deltaUV: Swift.Int16, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct LightCTLTemperatureGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightLCPropertyStatus : SensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public let property: DeviceProperty
  public let propertyValue: DevicePropertyCharacteristic
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: DeviceProperty, value: DevicePropertyCharacteristic)
  public init?(parameters: Foundation.Data)
}
public struct SceneDeleteUnacknowledged : GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let scene: SceneNumber
  public init(_ scene: SceneNumber)
  public init?(parameters: Foundation.Data)
}
public struct GenericOnPowerUpGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public enum AccessError : Swift.Error {
  case invalidSource
  case invalidElement
  case invalidTtl
  case invalidDestination
  case modelNotBoundToAppKey
  case noDeviceKey
  case cannotDelete
  case timeout
  public static func == (a: AccessError, b: AccessError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension AccessError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension MeshNetwork {
  public var localProvisioner: Provisioner? {
    get
  }
  public func setLocalProvisioner(_ provisioner: Provisioner) throws
  @discardableResult
  public func restoreLocalProvisioner() -> Swift.Bool
  public func isLocalProvisioner(_ provisioner: Provisioner) -> Swift.Bool
  public func add(provisioner: Provisioner) throws
  public func add(provisioner: Provisioner, withAddress unicastAddress: Address?) throws
  @discardableResult
  public func remove(provisionerAt index: Swift.Int) throws -> Provisioner
  public func remove(provisioner: Provisioner) throws
  public func moveProvisioner(fromIndex: Swift.Int, toIndex: Swift.Int)
  public func moveProvisioner(_ provisioner: Provisioner, toIndex: Swift.Int)
  public func assign(unicastAddress address: Address, for provisioner: Provisioner) throws
  public func disableConfigurationCapabilities(for provisioner: Provisioner)
}
public struct UnknownMessage : MeshMessage {
  public var opCode: Swift.UInt32 {
    get
  }
  public let parameters: Foundation.Data?
  public init?(parameters: Foundation.Data)
}
extension UnknownMessage : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct SceneStore : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let scene: SceneNumber
  public init(_ scene: SceneNumber)
  public init?(parameters: Foundation.Data)
}
public struct SensorSettingStatus : SensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public enum SensorSettingAccess : Swift.UInt8 {
    case readonly
    case readwrite
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public let property: DeviceProperty
  public let settingProperty: DeviceProperty
  public let settingAccess: SensorSettingStatus.SensorSettingAccess?
  public let settingValue: DevicePropertyCharacteristic?
  public var parameters: Foundation.Data? {
    get
  }
  public init(settingNotFound setting: DeviceProperty, for property: DeviceProperty)
  public init(_ setting: DeviceProperty, of property: DeviceProperty, access: SensorSettingStatus.SensorSettingAccess, value: DevicePropertyCharacteristic)
  public init?(parameters: Foundation.Data)
}
@_hasMissingDesignatedInitializers public class HeartbeatPublication : Swift.Codable {
  final public let address: Address
  final public let periodLog: Swift.UInt8
  public var period: Swift.UInt16 {
    get
  }
  final public let ttl: Swift.UInt8
  final public let networkKeyIndex: KeyIndex
  final public let features: NodeFeatures
  public var isEnabled: Swift.Bool {
    get
  }
  public var isPeriodicPublicationEnabled: Swift.Bool {
    get
  }
  public var isFeatureTriggeredPublishingEnabled: Swift.Bool {
    get
  }
  required public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
public enum Location : Swift.UInt16, Swift.Codable {
  case auxiliary
  case back
  case backup
  case bottom
  case eighteenth
  case eighth
  case eightieth
  case eightyEighth
  case eightyFifth
  case eightyFirst
  case eightyFourth
  case eightyNineth
  case eightySecond
  case eightySeventh
  case eightySixth
  case eightyThird
  case eleventh
  case external
  case fifteenth
  case fifth
  case fiftieth
  case fiftyEighth
  case fiftyFifth
  case fiftyFirst
  case fiftyFourth
  case fiftyNineth
  case fiftySecond
  case fiftySeventh
  case fiftySixth
  case fiftyThird
  case first
  case flash
  case fortieth
  case fourteenth
  case fourth
  case fourtyEighth
  case fourtyFifth
  case fourtyFirst
  case fourtyFourth
  case fourtyNineth
  case fourtySecond
  case fourtySeventh
  case fourtySixth
  case fourtyThird
  case front
  case inside
  case `internal`
  case left
  case lower
  case main
  case nineteenth
  case nineth
  case ninetieth
  case ninetyEighth
  case ninetyFifth
  case ninetyFirst
  case ninetyFourth
  case ninetyNineth
  case ninetySecond
  case ninetySeventh
  case ninetySixth
  case ninetyThird
  case oneHundredAndEighteenth
  case oneHundredAndEighth
  case oneHundredAndEightyEighth
  case oneHundredAndEightyFifth
  case oneHundredAndEightyFirst
  case oneHundredAndEightyFourth
  case oneHundredAndEightyNineth
  case oneHundredAndEightySecond
  case oneHundredAndEightySeventh
  case oneHundredAndEightySixth
  case oneHundredAndEightyThird
  case oneHundredAndEleventh
  case oneHundredAndFifteenth
  case oneHundredAndFifth
  case oneHundredAndFiftyEighth
  case oneHundredAndFiftyFifth
  case oneHundredAndFiftyFirst
  case oneHundredAndFiftyFourth
  case oneHundredAndFiftyNineth
  case oneHundredAndFiftySecond
  case oneHundredAndFiftySeventh
  case oneHundredAndFiftySixth
  case oneHundredAndFiftyThird
  case oneHundredAndFirst
  case oneHundredAndFourteenth
  case oneHundredAndFourth
  case oneHundredAndFourtyEighth
  case oneHundredAndFourtyFifth
  case oneHundredAndFourtyFirst
  case oneHundredAndFourtyFourth
  case oneHundredAndFourtyNineth
  case oneHundredAndFourtySecond
  case oneHundredAndFourtySeventh
  case oneHundredAndFourtySixth
  case oneHundredAndFourtyThird
  case oneHundredAndNineteenth
  case oneHundredAndNineth
  case oneHundredAndNinetyEighth
  case oneHundredAndNinetyFifth
  case oneHundredAndNinetyFirst
  case oneHundredAndNinetyFourth
  case oneHundredAndNinetyNineth
  case oneHundredAndNinetySecond
  case oneHundredAndNinetySeventh
  case oneHundredAndNinetySixth
  case oneHundredAndNinetyThird
  case oneHundredAndSecond
  case oneHundredAndSeventeenth
  case oneHundredAndSeventh
  case oneHundredAndSeventyEighth
  case oneHundredAndSeventyFifth
  case oneHundredAndSeventyFirst
  case oneHundredAndSeventyFourth
  case oneHundredAndSeventyNineth
  case oneHundredAndSeventySecond
  case oneHundredAndSeventySeventh
  case oneHundredAndSeventySixth
  case oneHundredAndSeventyThird
  case oneHundredAndSixteenth
  case oneHundredAndSixth
  case oneHundredAndSixtyEighth
  case oneHundredAndSixtyFifth
  case oneHundredAndSixtyFirst
  case oneHundredAndSixtyFourth
  case oneHundredAndSixtyNineth
  case oneHundredAndSixtySecond
  case oneHundredAndSixtySeventh
  case oneHundredAndSixtySixth
  case oneHundredAndSixtyThird
  case oneHundredAndTenth
  case oneHundredAndThird
  case oneHundredAndThirteenth
  case oneHundredAndThirtyEighth
  case oneHundredAndThirtyFifth
  case oneHundredAndThirtyFirst
  case oneHundredAndThirtyFourth
  case oneHundredAndThirtyNineth
  case oneHundredAndThirtySecond
  case oneHundredAndThirtySeventh
  case oneHundredAndThirtySixth
  case oneHundredAndThirtyThird
  case oneHundredAndTwelveth
  case oneHundredAndTwentyEighth
  case oneHundredAndTwentyFifth
  case oneHundredAndTwentyFirst
  case oneHundredAndTwentyFourth
  case oneHundredAndTwentyNineth
  case oneHundredAndTwentySecond
  case oneHundredAndTwentySeventh
  case oneHundredAndTwentySixth
  case oneHundredAndTwentyThird
  case oneHundredEightieth
  case oneHundredFiftieth
  case oneHundredFortieth
  case oneHundredNinetieth
  case oneHundredSeventieth
  case oneHundredSixtieth
  case oneHundredThirtieth
  case oneHundredTwentieth
  case oneHundredth
  case outside
  case right
  case second
  case seventeenth
  case seventh
  case seventieth
  case seventyEighth
  case seventyFifth
  case seventyFirst
  case seventyFourth
  case seventyNineth
  case seventySecond
  case seventySeventh
  case seventySixth
  case seventyThird
  case sixteenth
  case sixth
  case sixtieth
  case sixtyEighth
  case sixtyFifth
  case sixtyFirst
  case sixtyFourth
  case sixtyNineth
  case sixtySecond
  case sixtySeventh
  case sixtySixth
  case sixtyThird
  case supplementary
  case tenth
  case third
  case thirteenth
  case thirtieth
  case thirtyEighth
  case thirtyFifth
  case thirtyFirst
  case thirtyFourth
  case thirtyNineth
  case thirtySecond
  case thirtySeventh
  case thirtySixth
  case thirtyThird
  case top
  case twelveth
  case twentieth
  case twentyEighth
  case twentyFifth
  case twentyFirst
  case twentyFourth
  case twentyNineth
  case twentySecond
  case twentySeventh
  case twentySixth
  case twentyThird
  case twoHundredAndEighteenth
  case twoHundredAndEighth
  case twoHundredAndEleventh
  case twoHundredAndFifteenth
  case twoHundredAndFifth
  case twoHundredAndFiftyFifth
  case twoHundredAndFiftyFirst
  case twoHundredAndFiftyFourth
  case twoHundredAndFiftySecond
  case twoHundredAndFiftyThird
  case twoHundredAndFirst
  case twoHundredAndFourteenth
  case twoHundredAndFourth
  case twoHundredAndFourtyEighth
  case twoHundredAndFourtyFifth
  case twoHundredAndFourtyFirst
  case twoHundredAndFourtyFourth
  case twoHundredAndFourtyNineth
  case twoHundredAndFourtySecond
  case twoHundredAndFourtySeventh
  case twoHundredAndFourtySixth
  case twoHundredAndFourtyThird
  case twoHundredAndNineteenth
  case twoHundredAndNineth
  case twoHundredAndSecond
  case twoHundredAndSeventeenth
  case twoHundredAndSeventh
  case twoHundredAndSixteenth
  case twoHundredAndSixth
  case twoHundredAndTenth
  case twoHundredAndThird
  case twoHundredAndThirteenth
  case twoHundredAndThirtyEighth
  case twoHundredAndThirtyFifth
  case twoHundredAndThirtyFirst
  case twoHundredAndThirtyFourth
  case twoHundredAndThirtyNineth
  case twoHundredAndThirtySecond
  case twoHundredAndThirtySeventh
  case twoHundredAndThirtySixth
  case twoHundredAndThirtyThird
  case twoHundredAndTwelveth
  case twoHundredAndTwentyEighth
  case twoHundredAndTwentyFifth
  case twoHundredAndTwentyFirst
  case twoHundredAndTwentyFourth
  case twoHundredAndTwentyNineth
  case twoHundredAndTwentySecond
  case twoHundredAndTwentySeventh
  case twoHundredAndTwentySixth
  case twoHundredAndTwentyThird
  case twoHundredFiftieth
  case twoHundredFortieth
  case twoHundredThirtieth
  case twoHundredTwentieth
  case twoHundredth
  case unknown
  case upper
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
extension Location : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct LightHSLHueSetUnacknowledged : GenericMessage, TransactionMessage, TransitionMessage {
  public static var opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let hue: Swift.UInt16
  public let transitionTime: TransitionTime?
  public let delay: Swift.UInt8?
  public init(hue: Swift.UInt16)
  public init(hue: Swift.UInt16, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct ConfigRelaySet : AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let state: NodeFeatureState
  public let count: Swift.UInt8
  public let steps: Swift.UInt8
  public var interval: Foundation.TimeInterval {
    get
  }
  public init()
  public init(count: Swift.UInt8, steps: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct LightCTLSet : AcknowledgedGenericMessage, TransactionMessage, TransitionMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let temperature: Swift.UInt16
  public let deltaUV: Swift.Int16
  public var transitionTime: TransitionTime?
  public var delay: Swift.UInt8?
  public init(lightness: Swift.UInt16, temperature: Swift.UInt16, deltaUV: Swift.Int16)
  public init(lightness: Swift.UInt16, temperature: Swift.UInt16, deltaUV: Swift.Int16, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public class MeshNetworkManager {
  public var proxyFilter: ProxyFilter {
    get
  }
  weak public var logger: (any LoggerDelegate)?
  weak public var delegate: (any MeshNetworkDelegate)?
  weak public var transmitter: (any Transmitter)?
  public var defaultTtl: Swift.UInt8
  public var incompleteMessageTimeout: Swift.Double
  public var acknowledgmentTimerInterval: Swift.Double
  public var transmissionTimerInterval: Swift.Double
  public var retransmissionLimit: Swift.Int
  public var acknowledgmentMessageTimeout: Swift.Double
  public var acknowledgmentMessageInterval: Swift.Double
  public var allowIvIndexRecoveryOver42: Swift.Bool
  public var ivUpdateTestMode: Swift.Bool
  public var meshNetwork: MeshNetwork? {
    get
  }
  public var isNetworkCreated: Swift.Bool {
    get
  }
  public init(using storage: any Storage = LocalStorage(), queue: Dispatch.DispatchQueue = DispatchQueue.global(qos: .background), delegateQueue: Dispatch.DispatchQueue = DispatchQueue.main)
  convenience public init(using fileName: Swift.String)
  @objc deinit
}
extension MeshNetworkManager {
  public func createNewMeshNetwork(withName name: Swift.String, by provisionerName: Swift.String) -> MeshNetwork
  public func createNewMeshNetwork(withName name: Swift.String, meshUUID: Foundation.UUID = UUID(), by provisioner: Provisioner) -> MeshNetwork
  public var localElements: [Element] {
    get
    set
  }
}
extension MeshNetworkManager {
  public func provision(unprovisionedDevice: UnprovisionedDevice, over bearer: any ProvisioningBearer) throws -> ProvisioningManager
}
extension MeshNetworkManager {
  public func bearerDidDeliverData(_ data: Foundation.Data, ofType type: PduType)
  @discardableResult
  public func publish(_ message: any MeshMessage, from model: Model) -> MessageHandle?
  @discardableResult
  public func send(_ message: any MeshMessage, from localElement: Element? = nil, to destination: MeshAddress, withTtl initialTtl: Swift.UInt8? = nil, using applicationKey: ApplicationKey) throws -> MessageHandle
  @discardableResult
  public func send(_ message: any MeshMessage, from localElement: Element? = nil, to group: Group, withTtl initialTtl: Swift.UInt8? = nil, using applicationKey: ApplicationKey) throws -> MessageHandle
  @discardableResult
  public func send(_ message: any MeshMessage, from localElement: Element? = nil, to model: Model, withTtl initialTtl: Swift.UInt8? = nil) throws -> MessageHandle
  @discardableResult
  public func send(_ message: any MeshMessage, from localModel: Model, to model: Model, withTtl initialTtl: Swift.UInt8? = nil) throws -> MessageHandle
  @discardableResult
  public func send(_ message: any ConfigMessage, to destination: Address, withTtl initialTtl: Swift.UInt8? = nil) throws -> MessageHandle
  @discardableResult
  public func send(_ message: any ConfigMessage, to node: Node, withTtl initialTtl: Swift.UInt8? = nil) throws -> MessageHandle
  @discardableResult
  public func sendToLocalNode(_ message: any ConfigMessage) throws -> MessageHandle
  public func send(_ message: any ProxyConfigurationMessage) throws
  public func cancel(_ messageId: MessageHandle) throws
}
extension MeshNetworkManager : BearerDataDelegate {
  public func bearer(_ bearer: any Bearer, didDeliverData data: Foundation.Data, ofType type: PduType)
}
extension MeshNetworkManager {
  public func setSequenceNumber(_ sequence: Swift.UInt32, forLocalElement element: Element)
  public func getSequenceNumber(ofLocalElement element: Element) -> Swift.UInt32?
}
extension MeshNetworkManager {
  public func load() throws -> Swift.Bool
  public func save() -> Swift.Bool
}
extension MeshNetworkManager {
  public func export() -> Foundation.Data
  public func export(_ configuration: ExportConfiguration) -> Foundation.Data
  public func `import`(from data: Foundation.Data) throws -> MeshNetwork
}
public struct GenericDefaultTransitionTimeGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
extension MeshNetwork {
  public var nextAvailableApplicationKeyIndex: KeyIndex? {
    get
  }
  public var nextAvailableNetworkKeyIndex: KeyIndex? {
    get
  }
  @discardableResult
  public func add(applicationKey: Foundation.Data, withIndex index: KeyIndex? = nil, name: Swift.String) throws -> ApplicationKey
  public func remove(applicationKeyWithKeyIndex index: KeyIndex, force: Swift.Bool = false) throws
  public func remove(applicationKeyAt index: Swift.Int, force: Swift.Bool = false) throws -> ApplicationKey
  public func remove(applicationKey: ApplicationKey, force: Swift.Bool = false) throws
  @discardableResult
  public func add(networkKey: Foundation.Data, withIndex index: KeyIndex? = nil, name: Swift.String) throws -> NetworkKey
  public func remove(networkKeyWithKeyIndex index: KeyIndex, force: Swift.Bool = false) throws
  public func remove(networkKeyAt index: Swift.Int, force: Swift.Bool = false) throws -> NetworkKey
  public func remove(networkKey: NetworkKey, force: Swift.Bool = false) throws
}
public struct ConfigVendorModelSubscriptionGet : AcknowledgedConfigMessage, ConfigVendorModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let elementAddress: Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16
  public init?(of model: Model)
  public init?(parameters: Foundation.Data)
}
public struct LightCTLTemperatureSetUnacknowledged : GenericMessage, TransactionMessage, TransitionMessage {
  public static let opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let temperature: Swift.UInt16
  public let deltaUV: Swift.Int16
  public var transitionTime: TransitionTime?
  public var delay: Swift.UInt8?
  public init(temperature: Swift.UInt16, deltaUV: Swift.Int16)
  public init(temperature: Swift.UInt16, deltaUV: Swift.Int16, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct ConfigFriendStatus : ConfigMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let state: NodeFeatureState
  public init(_ state: NodeFeatureState)
  public init(for node: Node)
  public init?(parameters: Foundation.Data)
}
public struct ConfigAppKeyDelete : AcknowledgedConfigMessage, ConfigNetAndAppKeyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: KeyIndex
  public let applicationKeyIndex: KeyIndex
  public init(applicationKey: ApplicationKey)
  public init?(parameters: Foundation.Data)
}
public enum VendorMessageOpCode : Swift.String {
  case VendorMessage_Attr_Get
  case VendorMessage_Attr_Set
  case VendorMessage_Attr_Set_Unacknowledged
  case VendorMessage_Attr_Status
  case VendorMessage_Heartbeat
  case VendorMessage_Attr_Sync
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum MeshMessageSendStatusCode : Swift.Int {
  case MeshMessageSendStatus_Success
  case MeshMessageSendStatus_NoNode
  case MeshMessageSendStatus_NoElement
  case MeshMessageSendStatus_NoModel
  case MeshMessageSendStatus_NoAppKey
  case MeshMessageSendStatus_NetworkKey_UnbindAppKey
  case MeshMessageSendStatus_timeout
  case MeshMessageSendStatus_Disconnect
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension MeshSDK : MeshNetworkDelegate {
  public func sendMeshMessage(opCode: Swift.String, uuid: Swift.String, elementIndex: Swift.Int = 0, tid: Swift.String? = nil, message: Any, repeatNum: Swift.Int = 1, timeout: Foundation.TimeInterval? = nil, networkKey: Swift.String? = nil, isQueue: Swift.Bool = true, isRetry: Swift.Bool = false, callback: MeshSDK.MXMeshMessageCallBack? = nil)
  @objc dynamic public func sendMessage(address: Swift.String, opCode: Swift.String, tid: Swift.String? = nil, message: Any, networkKey: Swift.String, repeatNum: Swift.Int = 1, isQueue: Swift.Bool = true)
  public func meshNetworkManager(_ manager: MeshNetworkManager, didReceiveMessage message: any MeshMessage, sentFrom source: Address, to destination: Address)
  public func meshNetworkManager(_ manager: MeshNetworkManager, didSendMessage message: any MeshMessage, from localElement: Element, to destination: Address)
  public func meshNetworkManager(_ manager: MeshNetworkManager, failedToSendMessage message: any MeshMessage, from localElement: Element, to destination: Address, error: any Swift.Error)
  public func meshNetworkManager(_ manager: MeshNetworkManager, ivIndexDidUpdate index: Swift.UInt32)
}
public enum ProvisioningState {
  case ready
  case requestingCapabilities
  case capabilitiesReceived(_: ProvisioningCapabilities)
  case provisioning
  case complete
  case fail(_: any Swift.Error)
}
public enum ProvisioningError : Swift.Error {
  case invalidState
  case invalidPdu
  case unsupportedAlgorithm
  case unsupportedDevice
  case invalidOobValueFormat
  case noAddressAvailable
  case addressNotSpecified
  case networkKeyNotSpecified
  case confirmationFailed
  case remoteError(_: RemoteProvisioningError)
  case keyGenerationFailed(_: Darwin.OSStatus)
}
public enum RemoteProvisioningError : Swift.UInt8 {
  case invalidPdu
  case invalidFormat
  case unexpectedPdu
  case confirmationFailed
  case outOfResources
  case decryptionFailed
  case unexpectedError
  case cannotAssignAddresses
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum AuthAction {
  case provideStaticKey(callback: (Foundation.Data) -> Swift.Void)
  case provideNumeric(maximumNumberOfDigits: Swift.UInt8, outputAction: OutputAction, callback: (Swift.UInt) -> Swift.Void)
  case provideAlphanumeric(maximumNumberOfCharacters: Swift.UInt8, callback: (Swift.String) -> Swift.Void)
  case displayNumber(_: Swift.UInt, inputAction: InputAction)
  case displayAlphanumeric(_: Swift.String)
}
extension ProvisioningState : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension ProvisioningError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension RemoteProvisioningError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public enum OnPowerUp : Swift.UInt8 {
  case off
  case `default`
  case restore
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension OnPowerUp : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct GenericPowerLevelSetUnacknowledged : GenericMessage, TransactionMessage, TransitionMessage {
  public static let opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let power: Swift.UInt16
  public let transitionTime: TransitionTime?
  public let delay: Swift.UInt8?
  public init(power: Swift.UInt16)
  public init(power: Swift.UInt16, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct ConfigNetKeyList : ConfigMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndexes: [KeyIndex]
  public init(networkKeys: [NetworkKey])
  public init?(parameters: Foundation.Data)
}
public struct LightLCModeSet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init(_ status: Swift.Bool)
  public init?(parameters: Foundation.Data)
}
@_hasMissingDesignatedInitializers public class Scene : Swift.Codable {
  final public let number: SceneNumber
  public var name: Swift.String
  public var addresses: [Address] {
    get
  }
  required public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
extension Scene : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: Scene, rhs: Scene) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ConfigModelSubscriptionOverwrite : AcknowledgedConfigMessage, ConfigAddressMessage, ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let address: Address
  public let elementAddress: Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public init?(group: Group, to model: Model)
  public init?(parameters: Foundation.Data)
}
public struct SetFilterType : StaticAcknowledgedProxyConfigurationMessage {
  public static let opCode: Swift.UInt8
  public static let responseType: any StaticProxyConfigurationMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let filterType: ProxyFilerType
  public init(_ type: ProxyFilerType)
  public init?(parameters: Foundation.Data)
}
extension Swift.Array where Element == ApplicationKey {
  public subscript(keyIndex: KeyIndex) -> ApplicationKey? {
    get
  }
  public func knownTo(node: Node) -> [ApplicationKey]
  public func notKnownTo(node: Node) -> [ApplicationKey]
}
public enum ExportConfiguration {
  public enum NetworkKeysConfiguration {
    case all
    case some([NetworkKey])
  }
  public enum ApplicationKeysConfiguration {
    case all
    case some([ApplicationKey])
  }
  public enum ProvisionersConfiguration {
    case all
    case one(Provisioner)
    case some([Provisioner])
  }
  public enum NodesConfiguration {
    case allWithDeviceKey
    case allWithoutDeviceKey
    case some(withDeviceKey: [Node], andSomeWithout: [Node])
  }
  public enum GroupsConfiguration {
    case all
    case related
    case some([Group])
  }
  public enum ScenesConfiguration {
    case all
    case related
    case some([Scene])
  }
  case full
  case partial(networkKeys: ExportConfiguration.NetworkKeysConfiguration, applicationKeys: ExportConfiguration.ApplicationKeysConfiguration, provisioners: ExportConfiguration.ProvisionersConfiguration, nodes: ExportConfiguration.NodesConfiguration, groups: ExportConfiguration.GroupsConfiguration = .related, scenes: ExportConfiguration.ScenesConfiguration = .related)
}
extension Foundation.Data {
  public static func random128BitKey() -> Foundation.Data
}
public struct ConfigModelSubscriptionDeleteAll : AcknowledgedConfigMessage, ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let elementAddress: Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public init?(from model: Model)
  public init?(parameters: Foundation.Data)
}
public struct TransitionTime {
  public let steps: Swift.UInt8
  public let stepResolution: StepResolution
  public var milliseconds: Swift.Int {
    get
  }
  public var interval: Foundation.TimeInterval {
    get
  }
  public init(steps: Swift.UInt8, stepResolution: StepResolution)
  public init()
  public init(_ interval: Foundation.TimeInterval)
}
extension TransitionTime {
  public static let immediate: TransitionTime
  public static let unknown: TransitionTime
  public var isKnown: Swift.Bool {
    get
  }
  public var isImmediate: Swift.Bool {
    get
  }
}
extension Swift.Optional where Wrapped == TransitionTime {
  public func or(_ defaultTransitionTime: TransitionTime?) -> TransitionTime
}
extension TransitionTime : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct ConfigNetKeyDelete : AcknowledgedConfigMessage, ConfigNetKeyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: KeyIndex
  public init(networkKey: NetworkKey)
  public init?(parameters: Foundation.Data)
}
public struct ConfigKeyRefreshPhaseStatus : ConfigNetKeyMessage, ConfigStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: KeyIndex
  public let status: ConfigMessageStatus
  public let phase: KeyRefreshPhase
  public init(responseTo request: any ConfigNetKeyMessage, with error: ConfigMessageStatus)
  public init(reportPhaseOf networkKey: NetworkKey)
  public init?(parameters: Foundation.Data)
}
public struct GenericOnPowerUpStatus : GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let state: OnPowerUp
  public init(state: OnPowerUp)
  public init?(parameters: Foundation.Data)
}
public struct LightHSLTargetStatus : GenericMessage, TransitionStatusMessage {
  public static var opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let targetLightness: Swift.UInt16
  public let targetHue: Swift.UInt16
  public let targetSaturation: Swift.UInt16
  public let remainingTime: TransitionTime?
  public init(targetLightness: Swift.UInt16, targetHue: Swift.UInt16, targetSaturation: Swift.UInt16)
  public init(targetLightness: Swift.UInt16, targetHue: Swift.UInt16, targetSaturation: Swift.UInt16, remainingTime: TransitionTime)
  public init?(parameters: Foundation.Data)
}
extension MeshNetwork {
  public func node(for provisioner: Provisioner) -> Node?
  public func node(for unprovisionedDevice: UnprovisionedDevice) -> Node?
  public func node(withUuid uuid: Foundation.UUID) -> Node?
  public func node(withAddress address: Address) -> Node?
  public func node(matchingHash hash: Foundation.Data, random: Foundation.Data) -> Node?
  public func matches(networkId: Foundation.Data) -> Swift.Bool
  public func matches(hash: Foundation.Data, random: Foundation.Data) -> Swift.Bool
  public func add(node: Node) throws
  public func remove(node: Node)
  public func update(node: Node)
}
@objc @_inheritsConvenienceInitializers @objcMembers open class MXMeshProvisionManager : ObjectiveC.NSObject {
  @objc public static let shared: MXMeshProvisionManager
  @objc public var isNeedCompositionData: Swift.Bool
  @objc weak public var provisionDelegate: (any MXMeshProvisioningDelegate)?
  @objc public var isBusy: Swift.Bool
  @objc public func mxProvisionFinish()
  @objc public func startUnprovisionedDeviceProvision(device: UnprovisionedDevice, peripheral: CoreBluetooth.CBPeripheral, networkKey: Swift.String, delegate: (any MXMeshProvisioningDelegate)? = nil)
  @objc public func nextGattSwitch()
  @objc public func startUnprovisionedDeviceProvision(mac: Swift.String, networkKey: Swift.String, delegate: (any MXMeshProvisioningDelegate)? = nil)
  @objc public func startUnprovisionedDeviceProvision(advertisementData: [Swift.String : Any], peripheral: CoreBluetooth.CBPeripheral, networkKey: Swift.String, provisioningDelegate: (any MXMeshProvisioningDelegate)? = nil)
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Model : Swift.Codable {
  public var modelIdentifier: Swift.UInt16 {
    get
  }
  public var companyIdentifier: Swift.UInt16? {
    get
  }
  public var isBluetoothSIGAssigned: Swift.Bool {
    get
  }
  public var subscriptions: [Group] {
    get
  }
  public var publish: Publish? {
    get
  }
  final public let delegate: (any ModelDelegate)?
  weak public var parentElement: Element?
  public init(modelId: Swift.UInt32)
  convenience public init(vendorModelId: Swift.UInt16, companyId: Swift.UInt16, delegate: any ModelDelegate)
  convenience public init(sigModelId: Swift.UInt16, delegate: any ModelDelegate)
  required public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
extension Model {
  public func copy(from model: Model)
  public func set(boundApplicationKeysWithIndexes applicationKeyIndexes: [KeyIndex])
  public func bind(applicationKeyWithIndex applicationKeyIndex: KeyIndex)
  public func unbind(applicationKeyWithIndex applicationKeyIndex: KeyIndex)
  public func set(publication publish: Publish)
  public func clearPublication()
  public func subscribe(to group: Group)
  public func unsubscribe(from group: Group)
  public func unsubscribe(from address: Address)
  public func unsubscribeFromAll()
}
extension Model : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: Model, rhs: Model) -> Swift.Bool
  public static func != (lhs: Model, rhs: Model) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum KeyRefreshPhase : Swift.Int, Swift.Codable {
  case normalOperation
  case keyDistribution
  case usingNewKeys
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum KeyRefreshPhaseTransition : Swift.UInt8 {
  case useNewKeys
  case revokeOldKeys
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension KeyRefreshPhase : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension KeyRefreshPhaseTransition : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public protocol Storage {
  func load() -> Foundation.Data?
  func save(_ data: Foundation.Data) -> Swift.Bool
}
open class LocalStorage : Storage {
  public init(fileName: Swift.String = "MeshNetwork.json")
  public func load() -> Foundation.Data?
  public func save(_ data: Foundation.Data) -> Swift.Bool
  open func getStorageFile() -> Foundation.URL?
  @objc deinit
}
public struct LightLCModeSetUnacknowledged : GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public init(_ status: Swift.Bool)
  public init?(parameters: Foundation.Data)
}
extension Swift.ClosedRange where Bound == Swift.UInt16 {
  public func isInside(_ other: Swift.ClosedRange<Swift.UInt16>) -> Swift.Bool
}
public struct ConfigNodeIdentityGet : AcknowledgedConfigMessage, ConfigNetKeyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: KeyIndex
  public init(networkKey: NetworkKey)
  public init?(parameters: Foundation.Data)
}
@_inheritsConvenienceInitializers open class PBGattBearer : BaseGattProxyBearer<MeshProvisioningService>, ProvisioningBearer {
  override public var supportedPduTypes: PduTypes {
    get
  }
  override public init(targetWithIdentifier uuid: Foundation.UUID)
  @objc deinit
}
extension Node {
  public var isCompositionDataReceived: Swift.Bool {
    get
  }
  public var isProvisioner: Swift.Bool {
    get
  }
  public var isLocalProvisioner: Swift.Bool {
    get
  }
  public var provisioner: Provisioner? {
    get
  }
}
extension Foundation.Data {
  public var hex: Swift.String {
    get
  }
}
public struct SensorCadenceSet : AcknowledgedSensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public let property: DeviceProperty
  public let cadence: SensorCadence
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: DeviceProperty, to cadence: SensorCadence)
  public init?(parameters: Foundation.Data)
}
public struct LightLCLightOnOffSet : AcknowledgedGenericMessage, TransactionMessage, TransitionMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let isOn: Swift.Bool
  public let transitionTime: TransitionTime?
  public let delay: Swift.UInt8?
  public init(_ isOn: Swift.Bool)
  public init(_ isOn: Swift.Bool, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct SceneStatus : GenericMessage, SceneStatusMessage, TransitionStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: SceneMessageStatus
  public let remainingTime: TransitionTime?
  public let scene: SceneNumber
  public let targetScene: SceneNumber?
  public init(report scene: SceneNumber)
  public init(report scene: SceneNumber, with status: SceneMessageStatus)
  public init(report targetScene: SceneNumber, remainingTime: TransitionTime)
  public init?(parameters: Foundation.Data)
}
public struct SceneRecall : AcknowledgedGenericMessage, TransactionMessage, TransitionMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let scene: SceneNumber
  public let transitionTime: TransitionTime?
  public let delay: Swift.UInt8?
  public init(_ scene: SceneNumber)
  public init(_ scene: SceneNumber, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct LightLCLightOnOffGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct GenericPowerDefaultStatus : GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let power: Swift.UInt16
  public init(power: Swift.UInt16)
  public init?(parameters: Foundation.Data)
}
public struct OobInformation : Swift.OptionSet {
  public let rawValue: Swift.UInt16
  public static let other: OobInformation
  public static let electronicURI: OobInformation
  public static let qrCode: OobInformation
  public static let barCode: OobInformation
  public static let nfc: OobInformation
  public static let number: OobInformation
  public static let string: OobInformation
  public static let onBox: OobInformation
  public static let insideBox: OobInformation
  public static let onPieceOfPaper: OobInformation
  public static let insideManual: OobInformation
  public static let onDevice: OobInformation
  public init(rawValue: Swift.UInt16)
  public typealias ArrayLiteralElement = OobInformation
  public typealias Element = OobInformation
  public typealias RawValue = Swift.UInt16
}
public enum AuthenticationMethod {
  case noOob
  case staticOob
  case outputOob(action: OutputAction, size: Swift.UInt8)
  case inputOob(action: InputAction, size: Swift.UInt8)
}
public enum OutputAction : Swift.UInt8 {
  case blink
  case beep
  case vibrate
  case outputNumeric
  case outputAlphanumeric
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum InputAction : Swift.UInt8 {
  case push
  case twist
  case inputNumeric
  case inputAlphanumeric
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct StaticOobType : Swift.OptionSet {
  public let rawValue: Swift.UInt8
  public static let staticOobInformationAvailable: StaticOobType
  public init(rawValue: Swift.UInt8)
  public var count: Swift.Int {
    get
  }
  public typealias ArrayLiteralElement = StaticOobType
  public typealias Element = StaticOobType
  public typealias RawValue = Swift.UInt8
}
public struct OutputOobActions : Swift.OptionSet {
  public let rawValue: Swift.UInt16
  public static let blink: OutputOobActions
  public static let beep: OutputOobActions
  public static let vibrate: OutputOobActions
  public static let outputNumeric: OutputOobActions
  public static let outputAlphanumeric: OutputOobActions
  public init(rawValue: Swift.UInt16)
  public var count: Swift.Int {
    get
  }
  public typealias ArrayLiteralElement = OutputOobActions
  public typealias Element = OutputOobActions
  public typealias RawValue = Swift.UInt16
}
public struct InputOobActions : Swift.OptionSet {
  public let rawValue: Swift.UInt16
  public static let push: InputOobActions
  public static let twist: InputOobActions
  public static let inputNumeric: InputOobActions
  public static let inputAlphanumeric: InputOobActions
  public init(rawValue: Swift.UInt16)
  public var count: Swift.Int {
    get
  }
  public typealias ArrayLiteralElement = InputOobActions
  public typealias Element = InputOobActions
  public typealias RawValue = Swift.UInt16
}
extension OobInformation : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension AuthenticationMethod : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension OutputAction : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension InputAction : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension StaticOobType : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension OutputOobActions : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension InputOobActions : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Model {
  public var boundApplicationKeys: [ApplicationKey] {
    get
  }
  public func isBoundTo(_ applicationKey: ApplicationKey) -> Swift.Bool
}
public struct LightHSLRangeSetUnacknowledged : GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let minHue: Swift.UInt16
  public let maxHue: Swift.UInt16
  public let minSaturation: Swift.UInt16
  public let maxSaturation: Swift.UInt16
  public var hueRange: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public var saturationRange: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public init(hueRange: Swift.ClosedRange<Swift.UInt16>, saturationRange: Swift.ClosedRange<Swift.UInt16>)
  public init?(parameters: Foundation.Data)
}
public struct SceneRecallUnacknowledged : GenericMessage, TransactionMessage, TransitionMessage {
  public static let opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let scene: SceneNumber
  public let transitionTime: TransitionTime?
  public let delay: Swift.UInt8?
  public init(_ scene: SceneNumber)
  public init(_ scene: SceneNumber, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
@objc @_inheritsConvenienceInitializers public class MXMeshDeviceMessage : ObjectiveC.NSObject {
  public static func fetchDeviceTriplet(uuid: Swift.String, callback: @escaping ([Swift.String : Any]) -> ())
  public static func fogDeviceTriplet(uuid: Swift.String, callback: @escaping ([Swift.String : Any]) -> ())
  public static func fetchDeviceFirmwareVersion(uuid: Swift.String, callback: @escaping (Swift.String) -> ())
  public static func triggerVirtualButton(vid: Swift.String, networkKey: Swift.String, repeatNum: Swift.Int)
  public static func sendWiFiPasswordToDevice(uuid: Swift.String, ssid: Swift.String, password: Swift.String?, isUpdate: Swift.Bool = false, callback: @escaping (Swift.Bool) -> ())
  public static func groupAddDevice(uuid: Swift.String, groups: [[Swift.String : Any]]? = nil, callback: @escaping (Swift.Bool) -> ())
  public static func groupDeleteDevice(uuid: Swift.String, groups: [[Swift.String : Any]]? = nil, callback: @escaping (Swift.Bool) -> ())
  public static func resetDeviceGroupSetting(uuid: Swift.String, groups: [[Swift.String : Any]]? = nil, callback: @escaping (Swift.Bool) -> ())
  public static func subscribeGroup(uuid: Swift.String, address: Swift.Int, callback: @escaping (Swift.Bool) -> ())
  public static func rebootDevice(uuid: Swift.String)
  @objc override dynamic public init()
  @objc deinit
}
public struct ConfigModelSubscriptionStatus : ConfigStatusMessage, ConfigAddressMessage, ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: ConfigMessageStatus
  public let address: Address
  public let elementAddress: Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public init<T>(responseTo request: T, with status: ConfigMessageStatus) where T : ConfigAddressMessage, T : ConfigAnyModelMessage
  public init<T>(responseTo request: T, with status: ConfigMessageStatus) where T : ConfigAnyModelMessage, T : ConfigVirtualLabelMessage
  public init(responseTo request: ConfigModelSubscriptionDeleteAll, with status: ConfigMessageStatus)
  public init?(confirmAdding group: Group, to model: Model)
  public init?(confirmDeleting address: Address, from model: Model)
  public init?(confirmDeletingAllFrom model: Model)
  public init?(parameters: Foundation.Data)
}
public struct SensorDescriptorStatus : SensorMessage {
  public static let opCode: Swift.UInt32
  public enum Result {
    case descriptors([SensorDescriptor])
    case propertyNotFound(DeviceProperty)
  }
  public let result: SensorDescriptorStatus.Result
  public var parameters: Foundation.Data? {
    get
  }
  public init(propertyNotFound property: DeviceProperty)
  public init(_ descriptors: [SensorDescriptor])
  public init?(parameters: Foundation.Data)
}
public struct LightHSLSaturationSet : AcknowledgedGenericMessage, TransactionMessage, TransitionMessage {
  public static var opCode: Swift.UInt32
  public static var responseType: any StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let saturation: Swift.UInt16
  public let transitionTime: TransitionTime?
  public let delay: Swift.UInt8?
  public init(saturation: Swift.UInt16)
  public init(saturation: Swift.UInt16, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct ConfigNodeResetStatus : ConfigMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct GenericPowerDefaultGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightCTLTDefaultGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct ConfigSIGModelSubscriptionGet : AcknowledgedConfigMessage, ConfigModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let elementAddress: Address
  public let modelIdentifier: Swift.UInt16
  public init?(of model: Model)
  public init?(parameters: Foundation.Data)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objcMembers open class MXMeshMessageHandle : ObjectiveC.NSObject {
  @objc public static var shard: MXMeshMessageHandle
  @objc public var attrParams: [Swift.String : Any]
  @objc public func updateTranscodingMapping(data: [Swift.String : Any]?)
  public static func identifierTakeOutService(oldIdentifier: Swift.String) -> (identifier: Swift.String, service: Swift.Int)
  @objc public static func createIdentifier(oldIdentifier: Swift.String, service: Swift.Int) -> Swift.String?
  @objc public static func identifierConvertToAttrType(identifier: Swift.String, attrMap: [Swift.String : Any]? = nil) -> Swift.String?
  @objc public static func properiesToMessageHex(identifier: Swift.String, value: Any, attrMap: [Swift.String : Any]? = nil) -> Swift.String?
  @objc public static func resolveMeshMessageToProperties(message: Swift.String, attrMap: [Swift.String : Any]? = nil) -> [Swift.String : Any]
  @objc public static func getMeshResolveMap(attrType: Swift.String, attrInfo: [Swift.String : Any]) -> [Swift.String : Any]?
  @objc deinit
}
public struct SensorCadenceStatus : SensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public let property: DeviceProperty
  public let cadence: SensorCadence?
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: DeviceProperty, cadence: SensorCadence?)
  public init?(parameters: Foundation.Data)
}
extension Node {
  public func knows(applicationKey: ApplicationKey) -> Swift.Bool
  public func knows(applicationKeyIndex: KeyIndex) -> Swift.Bool
  public func knows(networkKey: NetworkKey) -> Swift.Bool
  public func knows(networkKeyIndex: KeyIndex) -> Swift.Bool
  public func hasModelBoundTo(_ applicationKey: ApplicationKey) -> Swift.Bool
  public func hasApplicationKeyBoundTo(_ networkKey: NetworkKey) -> Swift.Bool
  public func applicationKeysAvailableFor(_ model: Model) -> [ApplicationKey]
}
extension Swift.Array where Element == Node {
  public func knows(applicationKey: ApplicationKey) -> Swift.Bool
  public func knows(applicationKeyIndex: KeyIndex) -> Swift.Bool
  public func knows(networkKey: NetworkKey) -> Swift.Bool
  public func knows(networkKeyIndex: KeyIndex) -> Swift.Bool
}
public struct ConfigVendorModelSubscriptionList : ConfigModelSubscriptionList, ConfigVendorModelMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: ConfigMessageStatus
  public let elementAddress: Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16
  public let addresses: [Address]
  public init(responseTo request: ConfigVendorModelSubscriptionGet, with addresses: [Address])
  public init(responseTo request: ConfigVendorModelSubscriptionGet, with status: ConfigMessageStatus)
  public init?(parameters: Foundation.Data)
}
public enum NodeIdentity : Swift.UInt8 {
  case stopped
  case running
  case notSupported
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension NodeIdentity : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@objc public class UnprovisionedDevice : ObjectiveC.NSObject {
  public var name: Swift.String?
  final public let uuid: Foundation.UUID
  final public let oobInformation: OobInformation
  public init(name: Swift.String? = nil, uuid: Foundation.UUID, oobInformation: OobInformation = OobInformation(rawValue: 0))
  public init?(advertisementData: [Swift.String : Any])
  @objc deinit
}
public protocol Key {
  var name: Swift.String { get set }
  var index: KeyIndex { get }
  var key: Foundation.Data { get }
}
public struct GenericPowerDefaultSet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let power: Swift.UInt16
  public init(power: Swift.UInt16)
  public init?(parameters: Foundation.Data)
}
public struct SensorCadenceSetUnacknowledged : SensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public let property: DeviceProperty
  public let cadence: SensorCadence
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: DeviceProperty, to cadence: SensorCadence)
  public init?(parameters: Foundation.Data)
}
public struct ConfigNetKeyStatus : ConfigNetKeyMessage, ConfigStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: KeyIndex
  public let status: ConfigMessageStatus
  public init(confirm networkKey: NetworkKey)
  public init(responseTo request: any ConfigNetKeyMessage, with status: ConfigMessageStatus)
  public init?(parameters: Foundation.Data)
}
extension MeshSDK {
  public func lookupNode(uuid: Swift.String) -> Node?
  public func getMeshNode(address: Swift.String) -> Node?
  @objc dynamic public func addNode(jsonObject: Swift.Dictionary<Swift.String, Any>) -> Swift.Bool
  @objc dynamic public func deleteNode(uuid: Swift.String) -> Swift.Bool
  @objc dynamic public func getNodeAddress(uuid: Swift.String) -> Swift.String
  @objc dynamic public func getNodeUUID(mac: Swift.String) -> Swift.String?
  public func getNodeElement(address: Swift.String) -> Element?
  @objc dynamic public func getNodeElementInfo(address: Swift.String) -> Swift.Dictionary<Swift.String, Any>?
  @objc dynamic public func getNodeInfo(uuid: Swift.String) -> Swift.Dictionary<Swift.String, Any>?
}
public struct LightLightnessRangeGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightLCModeStatus : GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public init(_ status: Swift.Bool)
  public init?(parameters: Foundation.Data)
}
public struct ConfigModelAppUnbind : AcknowledgedConfigMessage, ConfigAppKeyMessage, ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let applicationKeyIndex: KeyIndex
  public let elementAddress: Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public init?(applicationKey: ApplicationKey, to model: Model)
  public init?(parameters: Foundation.Data)
}
public struct GenericPowerRangeStatus : GenericStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: GenericMessageStatus
  public let range: Swift.ClosedRange<Swift.UInt16>
  public init(report range: Swift.ClosedRange<Swift.UInt16>)
  public init(_ status: GenericMessageStatus, for request: GenericPowerRangeSet)
  public init(_ status: GenericMessageStatus, for request: GenericPowerRangeSetUnacknowledged)
  public init?(parameters: Foundation.Data)
}
public class RangeObject {
  public var range: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public var lowerBound: Swift.UInt16 {
    get
  }
  public var upperBound: Swift.UInt16 {
    get
  }
  public var count: Swift.Int {
    get
  }
  required public init(from lowerBound: Swift.UInt16, to upperBound: Swift.UInt16)
  required public init(_ range: Swift.ClosedRange<Swift.UInt16>)
  @objc deinit
}
extension RangeObject : Swift.Equatable {
  public static func == (left: RangeObject, right: RangeObject) -> Swift.Bool
  public static func == (left: RangeObject, right: Swift.ClosedRange<Swift.UInt16>) -> Swift.Bool
  public static func != (left: RangeObject, right: RangeObject) -> Swift.Bool
  public static func != (left: RangeObject, right: Swift.ClosedRange<Swift.UInt16>) -> Swift.Bool
}
extension RangeObject : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public func + <T>(left: T, right: T) -> [T] where T : RangeObject
public func - <T>(left: T, right: T) -> [T] where T : RangeObject
public func + <T>(array: [T], other: T) -> [T] where T : RangeObject
public func + (array: [AddressRange], otherArray: [AddressRange]) -> [AddressRange]
public func + (array: [SceneRange], otherArray: [SceneRange]) -> [SceneRange]
public func - <T>(array: [T], other: T) -> [T] where T : RangeObject
public func - <T>(array: [T], otherArray: [T]) -> [T] where T : RangeObject
public func += <T>(array: inout [T], other: T) where T : RangeObject
public func += (array: inout [AddressRange], otherArray: [AddressRange])
public func += (array: inout [SceneRange], otherArray: [SceneRange])
public func -= <T>(array: inout [T], other: T) where T : RangeObject
public func -= <T>(array: inout [T], otherArray: [T]) where T : RangeObject
public struct LightHSLSet : AcknowledgedGenericMessage, TransactionMessage, TransitionMessage {
  public static var opCode: Swift.UInt32
  public static var responseType: any StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let hue: Swift.UInt16
  public let saturation: Swift.UInt16
  public let transitionTime: TransitionTime?
  public let delay: Swift.UInt8?
  public init(lightness: Swift.UInt16, hue: Swift.UInt16, saturation: Swift.UInt16)
  public init(lightness: Swift.UInt16, hue: Swift.UInt16, saturation: Swift.UInt16, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
@_hasMissingDesignatedInitializers public class MeshNetwork : Swift.Codable {
  final public let uuid: Foundation.UUID
  public var timestamp: Foundation.Date {
    get
  }
  final public let isPartial: Swift.Bool
  public var meshName: Swift.String {
    get
    set
  }
  public var provisioners: [Provisioner] {
    get
  }
  public var networkKeys: [NetworkKey] {
    get
  }
  public var applicationKeys: [ApplicationKey] {
    get
  }
  public var nodes: [Node] {
    get
  }
  public var groups: [Group] {
    get
  }
  public var scenes: [Scene] {
    get
  }
  public var currentNetworkKey: NetworkKey?
  required public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
public struct Publish : Swift.Codable {
  public static let disabled: Publish
  public struct Retransmit : Swift.Codable {
    public static let disabled: Publish.Retransmit
    public let count: Swift.UInt8
    public let interval: Swift.UInt16
    public var steps: Swift.UInt8 {
      get
    }
    public init()
    public init(_ count: Swift.UInt8, timesWithInterval interval: Foundation.TimeInterval)
    public init(publishRetransmitCount: Swift.UInt8, intervalSteps: Swift.UInt8)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Period : Swift.Codable {
    public static let disabled: Publish.Period
    public let numberOfSteps: Swift.UInt8
    public let resolution: StepResolution
    public let interval: Foundation.TimeInterval
    public init()
    public init(_ interval: Foundation.TimeInterval)
    public init(steps: Swift.UInt8, resolution: StepResolution)
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
  }
  public var publicationAddress: MeshAddress {
    get
  }
  public let index: KeyIndex
  public let ttl: Swift.UInt8
  public let period: Publish.Period
  public let retransmit: Publish.Retransmit
  public init(to destination: MeshAddress, using applicationKey: ApplicationKey, usingFriendshipMaterial friendshipCredentialsFlag: Swift.Bool, ttl: Swift.UInt8, period: Publish.Period, retransmit: Publish.Retransmit)
  @available(*, deprecated, message: "Use the other constructor")
  public init(to destination: MeshAddress, using applicationKey: ApplicationKey, usingFriendshipMaterial friendshipCredentialsFlag: Swift.Bool, ttl: Swift.UInt8, periodSteps: Swift.UInt8, periodResolution: StepResolution, retransmit: Publish.Retransmit)
  public init()
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Publish {
  public var isCancel: Swift.Bool {
    get
  }
  public var isUsingMasterSecurityMaterial: Swift.Bool {
    get
  }
  public var isUsingFriendshipSecurityMaterial: Swift.Bool {
    get
  }
}
extension Publish : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Publish.Retransmit : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Publish.Period : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct ConfigNetworkTransmitGet : AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightHSLSaturationGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessRangeSet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let min: Swift.UInt16
  public let max: Swift.UInt16
  public var range: Swift.ClosedRange<Swift.UInt16> {
    get
  }
  public init(_ range: Swift.ClosedRange<Swift.UInt16>)
  public init?(parameters: Foundation.Data)
}
extension MeshNetwork {
  public func isAddressRangeValid(_ address: Address, elementsCount count: Swift.UInt8) -> Swift.Bool
  public func isAddressRangeAvailable(_ address: Address, elementsCount count: Swift.UInt8, for node: Node? = nil) -> Swift.Bool
  public func nextAvailableUnicastAddress(startingFrom offset: Address = Address.minUnicastAddress, using provisioner: Provisioner) -> Address?
  public func nextAvailableUnicastAddress(startingFrom offset: Address = Address.minUnicastAddress, forElementsCount elementsCount: Swift.UInt8) -> Address?
  public func nextAvailableUnicastAddress(startingFrom offset: Address = Address.mx_minUnicastAddress, for elementsCount: Swift.UInt8, elementsUsing provisioner: Provisioner) -> Address?
  public func nextAvailableUnicastAddress(for provisioner: Provisioner) -> Address?
  public func nextAvailableGroupAddress(for provisioner: Provisioner) -> Address?
  public func nextAvailableGroupAddress() -> Address?
}
public struct GenericPowerLastGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct GenericLevelSetUnacknowledged : GenericMessage, TransactionMessage, TransitionMessage {
  public static let opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let level: Swift.Int16
  public let transitionTime: TransitionTime?
  public let delay: Swift.UInt8?
  public init(level: Swift.Int16)
  public init(level: Swift.Int16, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public typealias KeyIndex = Swift.UInt16
extension Swift.UInt16 {
  public var isValidKeyIndex: Swift.Bool {
    get
  }
}
public struct LightLightnessDefaultSet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public init(lightness: Swift.UInt16)
  public init?(parameters: Foundation.Data)
}
public enum ProxyFilerType : Swift.UInt8 {
  case inclusionList
  case exclusionList
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public protocol ProxyFilterDelegate : AnyObject {
  func proxyFilterUpdated(type: ProxyFilerType, addresses: Swift.Set<Address>)
  func proxyFilterUpdateAcknowledged(type: ProxyFilerType, listSize: Swift.UInt16)
  func limitedProxyFilterDetected(maxSize: Swift.Int)
}
extension ProxyFilterDelegate {
  public func limitedProxyFilterDetected(maxSize: Swift.Int)
}
public enum ProxyFilterSetup {
  case automatic
  case inclusionList(addresses: Swift.Set<Address>)
  case exclusionList(addresses: Swift.Set<Address>)
}
@_hasMissingDesignatedInitializers public class ProxyFilter {
  weak public var delegate: (any ProxyFilterDelegate)?
  public var initialState: ProxyFilterSetup
  public var addresses: Swift.Set<Address> {
    get
  }
  public var type: ProxyFilerType {
    get
  }
  public var proxy: Node? {
    get
  }
  @objc deinit
}
extension ProxyFilter {
  public func setType(_ type: ProxyFilerType)
  public func reset()
  public func clear()
  public func add(address: Address)
  public func add(addresses: [Address])
  public func add(addresses: Swift.Set<Address>)
  public func add(groups: [Group])
  public func remove(address: Address)
  public func remove(addresses: [Address])
  public func remove(addresses: Swift.Set<Address>)
  public func remove(groups: [Group])
  public func setup(for provisioner: Provisioner)
  public func proxyDidDisconnect()
}
extension ProxyFilerType : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct LightLightnessLinearStatus : GenericMessage, TransitionStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let targetLightness: Swift.UInt16?
  public let remainingTime: TransitionTime?
  public init(lightness: Swift.UInt16)
  public init(lightness: Swift.UInt16, targetLightness: Swift.UInt16, remainingTime: TransitionTime)
  public init?(parameters: Foundation.Data)
}
public struct ConfigAppKeyList : ConfigStatusMessage, ConfigNetKeyMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let status: ConfigMessageStatus
  public let networkKeyIndex: KeyIndex
  public let applicationKeyIndexes: [KeyIndex]
  public init(responseTo request: ConfigAppKeyGet, with applicationKeys: [ApplicationKey])
  public init(responseTo request: ConfigAppKeyGet, with status: ConfigMessageStatus)
  public init?(parameters: Foundation.Data)
}
extension Element {
  public func hasModelBoundTo(_ applicationKey: ApplicationKey) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @objcMembers open class MXMeshTool : ObjectiveC.NSObject {
  @objc public static func getFeatureFlag(uuid: Swift.String) -> Swift.UInt8
  public static func getCompanyId(uuid: Swift.String) -> Swift.UInt16?
  @objc public static func getNodeMacAddress(uuid: Swift.String) -> Swift.String
  @objc public static func getDeviceMacAddress(uuid: Swift.String) -> Swift.String
  @objc public static func getDeviceProductId(uuid: Swift.String) -> Swift.String
  @objc override dynamic public init()
  @objc deinit
}
extension Swift.String {
  public var bigEndian: Swift.String {
    get
  }
  public var littleEndian: Swift.String {
    get
  }
}
public struct LightLightnessDefaultGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightLCOccupancyModeSetUnacknowledged : GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public init(_ mode: Swift.Bool)
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessLinearSetUnacknowledged : GenericMessage, TransactionMessage, TransitionMessage {
  public static var opCode: Swift.UInt32
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let transitionTime: TransitionTime?
  public let delay: Swift.UInt8?
  public init(lightness: Swift.UInt16)
  public init(lightness: Swift.UInt16, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct ConfigHeartbeatPublicationGet : AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct GenericPowerLevelStatus : GenericMessage, TransitionStatusMessage {
  public static var opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let power: Swift.UInt16
  public let targetPower: Swift.UInt16?
  public let remainingTime: TransitionTime?
  public init(power: Swift.UInt16)
  public init(power: Swift.UInt16, targetPower: Swift.UInt16, remainingTime: TransitionTime)
  public init?(parameters: Foundation.Data)
}
public enum GattBearerError : Swift.Error {
  case deviceNotSupported
  public static func == (a: GattBearerError, b: GattBearerError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension GattBearerError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public struct LightLCPropertySetUnacknowledged : SensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public let property: DeviceProperty
  public let propertyValue: DevicePropertyCharacteristic
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: DeviceProperty, value: DevicePropertyCharacteristic)
  public init?(parameters: Foundation.Data)
}
public enum BatteryPresence : Swift.UInt8 {
  case notPresent
  case removable
  case notRemovable
  case unknown
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum BatteryIndicator : Swift.UInt8 {
  case criticallyLow
  case low
  case good
  case unknown
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum BatteryChargingState : Swift.UInt8 {
  case notChargeable
  case notCharging
  case charging
  case unknown
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum BatteryServiceability : Swift.UInt8 {
  case reserved
  case serviceNotRequired
  case serviceRequired
  case unknown
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct GenericBatteryStatus : GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let batteryLevel: Swift.UInt8
  public let timeToDischarge: Swift.UInt32
  public let timeToCharge: Swift.UInt32
  public let flags: Swift.UInt8
  public var isBatteryLevelKnown: Swift.Bool {
    get
  }
  public var isTimeToDischargeKnown: Swift.Bool {
    get
  }
  public var isTimeToChargeKnown: Swift.Bool {
    get
  }
  public var batteryPresence: BatteryPresence {
    get
  }
  public var batteryIndicator: BatteryIndicator {
    get
  }
  public var batteryChargingState: BatteryChargingState {
    get
  }
  public var batteryServiceability: BatteryServiceability {
    get
  }
  public init(level batteryLevel: Swift.UInt8, timeToDischarge: Swift.UInt32, andCharge timeToCharge: Swift.UInt32, battery batteryPresence: BatteryPresence, state batteryIndicator: BatteryIndicator, charging batteryChargingState: BatteryChargingState, service batteryServiceability: BatteryServiceability)
  public init?(parameters: Foundation.Data)
}
public struct ConfigLowPowerNodePollTimeoutGet : AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let lpnAddress: Address
  public init?(from address: Address)
  public init?(parameters: Foundation.Data)
}
public struct ConfigNodeIdentitySet : AcknowledgedConfigMessage, ConfigNetKeyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: KeyIndex
  public let identity: NodeIdentity
  public init(networkKey: NetworkKey, identity: NodeIdentity)
  public init?(parameters: Foundation.Data)
}
public struct GenericPowerRangeSetUnacknowledged : GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let range: Swift.ClosedRange<Swift.UInt16>
  public init(range: Swift.ClosedRange<Swift.UInt16>)
  public init?(parameters: Foundation.Data)
}
public struct LightLCOccupancyModeSet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init(_ mode: Swift.Bool)
  public init?(parameters: Foundation.Data)
}
public struct SensorSeriesGet : AcknowledgedSensorPropertyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public let property: DeviceProperty
  public let rawValueX1: Foundation.Data
  public let rawValueX2: Foundation.Data
  public var parameters: Foundation.Data? {
    get
  }
  public init(of property: DeviceProperty, rawValueX1: Foundation.Data, rawValueX2: Foundation.Data)
  public init?(parameters: Foundation.Data)
}
public protocol ProxyConfigurationMessage : BaseMeshMessage {
  var opCode: Swift.UInt8 { get }
}
public protocol StaticProxyConfigurationMessage : ProxyConfigurationMessage {
  static var opCode: Swift.UInt8 { get }
}
public protocol AcknowledgedProxyConfigurationMessage : ProxyConfigurationMessage {
  var responseOpCode: Swift.UInt8 { get }
}
public protocol StaticAcknowledgedProxyConfigurationMessage : AcknowledgedProxyConfigurationMessage, StaticProxyConfigurationMessage {
  static var responseType: any StaticProxyConfigurationMessage.Type { get }
}
extension StaticProxyConfigurationMessage {
  public var opCode: Swift.UInt8 {
    get
  }
}
extension StaticAcknowledgedProxyConfigurationMessage {
  public var responseOpCode: Swift.UInt8 {
    get
  }
}
public struct SceneGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct LightLightnessLinearSet : AcknowledgedGenericMessage, TransactionMessage, TransitionMessage {
  public static var opCode: Swift.UInt32
  public static var responseType: any StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let transitionTime: TransitionTime?
  public let delay: Swift.UInt8?
  public init(lightness: Swift.UInt16)
  public init(lightness: Swift.UInt16, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public struct LightCTLStatus : GenericMessage, TransitionStatusMessage {
  public static var opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let temperature: Swift.UInt16
  public let targetLightness: Swift.UInt16?
  public let targetTemperature: Swift.UInt16?
  public let remainingTime: TransitionTime?
  public init(lightness: Swift.UInt16, temperature: Swift.UInt16)
  public init(lightness: Swift.UInt16, temperature: Swift.UInt16, targetLightness: Swift.UInt16, targetTemperature: Swift.UInt16, remainingTime: TransitionTime)
  public init?(parameters: Foundation.Data)
}
public struct ConfigRelayStatus : ConfigMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let state: NodeFeatureState
  public let count: Swift.UInt8
  public let steps: Swift.UInt8
  public var interval: Foundation.TimeInterval {
    get
  }
  public init(_ state: NodeFeatureState, count: Swift.UInt8, steps: Swift.UInt8)
  public init(for node: Node)
  public init?(parameters: Foundation.Data)
}
public struct GenericDefaultTransitionTimeStatus : GenericMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let transitionTime: TransitionTime
  public init(transitionTime: TransitionTime)
  public init?(parameters: Foundation.Data)
}
@_hasMissingDesignatedInitializers public class Group : Swift.Codable {
  public var name: Swift.String {
    get
    set
  }
  final public let address: MeshAddress
  public var parent: Group? {
    get
    set
  }
  public init(name: Swift.String, address: MeshAddress) throws
  convenience public init(name: Swift.String, address: Address) throws
  required public init(from decoder: any Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Group : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: Group, rhs: Group) -> Swift.Bool
  public static func != (lhs: Group, rhs: Group) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Group {
  public static let allNodes: Group
  public static let allRelays: Group
  public static let allFriends: Group
  public static let allProxies: Group
  public static let specialGroups: [Group]
  public static func specialGroup(withAddress address: Address) -> Group?
  public static func specialGroup(withAddress address: MeshAddress) -> Group?
}
extension Model {
  public func isSubscribed(to group: Group) -> Swift.Bool
  public func isSubscribed(to address: MeshAddress) -> Swift.Bool
}
public struct LightLightnessSet : AcknowledgedGenericMessage, TransactionMessage, TransitionMessage {
  public static var opCode: Swift.UInt32
  public static var responseType: any StaticMeshMessage.Type
  public var tid: Swift.UInt8!
  public var parameters: Foundation.Data? {
    get
  }
  public let lightness: Swift.UInt16
  public let transitionTime: TransitionTime?
  public let delay: Swift.UInt8?
  public init(lightness: Swift.UInt16)
  public init(lightness: Swift.UInt16, transitionTime: TransitionTime, delay: Swift.UInt8)
  public init?(parameters: Foundation.Data)
}
public protocol CompositionDataPage {
  var page: Swift.UInt8 { get }
  var parameters: Foundation.Data? { get }
}
public struct ConfigCompositionDataStatus : ConfigMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let page: (any CompositionDataPage)?
  public init(report page: any CompositionDataPage)
  public init?(parameters: Foundation.Data)
}
public struct Page0 : CompositionDataPage {
  public let page: Swift.UInt8
  public let companyIdentifier: Swift.UInt16
  public let productIdentifier: Swift.UInt16
  public let versionIdentifier: Swift.UInt16
  public let minimumNumberOfReplayProtectionList: Swift.UInt16
  public let features: NodeFeaturesState
  public let elements: [Element]
  public var parameters: Foundation.Data? {
    get
  }
  public var isSegmented: Swift.Bool {
    get
  }
  public init(node: Node)
  public init?(parameters: Foundation.Data)
}
public struct ConfigModelSubscriptionVirtualAddressOverwrite : AcknowledgedConfigMessage, ConfigVirtualLabelMessage, ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let virtualLabel: Foundation.UUID
  public let elementAddress: Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public init?(group: Group, from model: Model)
  public init?(parameters: Foundation.Data)
}
public struct ConfigModelPublicationVirtualAddressSet : AcknowledgedConfigMessage, ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let elementAddress: Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public let publish: Publish
  public init?(_ publish: Publish, to model: Model)
  public init?(parameters: Foundation.Data)
}
public struct ConfigModelPublicationSet : AcknowledgedConfigMessage, ConfigAnyModelMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let elementAddress: Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public let publish: Publish
  public init?(_ publish: Publish, to model: Model)
  public init?(disablePublicationFor model: Model)
  public init?(parameters: Foundation.Data)
}
public struct ConfigAppKeyAdd : AcknowledgedConfigMessage, ConfigNetAndAppKeyMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let networkKeyIndex: KeyIndex
  public let applicationKeyIndex: KeyIndex
  public let key: Foundation.Data
  public init(applicationKey: ApplicationKey)
  public init?(parameters: Foundation.Data)
}
public struct ConfigRelayGet : AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
extension Group {
  public func scenes(onModelsBoundTo applicationKey: ApplicationKey) -> [Scene]
}
public enum ModelError : Swift.Error {
  case invalidMessage
  public static func == (a: ModelError, b: ModelError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol ModelDelegate : AnyObject {
  typealias MessageComposer = () -> any MeshMessage
  var messageTypes: [Swift.UInt32 : any MeshMessage.Type] { get }
  var isSubscriptionSupported: Swift.Bool { get }
  var publicationMessageComposer: Self.MessageComposer? { get }
  func model(_ model: Model, didReceiveAcknowledgedMessage request: any AcknowledgedMeshMessage, from source: Address, sentTo destination: MeshAddress) throws -> any MeshMessage
  func model(_ model: Model, didReceiveUnacknowledgedMessage message: any MeshMessage, from source: Address, sentTo destination: MeshAddress)
  func model(_ model: Model, didReceiveResponse response: any MeshMessage, toAcknowledgedMessage request: any AcknowledgedMeshMessage, from source: Address)
}
extension ModelDelegate {
  @discardableResult
  public func publish(_ message: any MeshMessage, using manager: MeshNetworkManager) -> MessageHandle?
  @discardableResult
  public func publish(using manager: MeshNetworkManager) -> MessageHandle?
}
public protocol SceneServerModelDelegate : ModelDelegate {
  func networkDidExitStoredWithSceneState()
}
public protocol StoredWithSceneModelDelegate : ModelDelegate {
  func store(with scene: SceneNumber)
  func recall(_ scene: SceneNumber, transitionTime: TransitionTime?, delay: Swift.UInt8?)
}
extension StoredWithSceneModelDelegate {
  public func networkDidExitStoredWithSceneState(_ network: MeshNetwork)
}
public class TransactionHelper {
  public init()
  public func isNewTransaction(_ message: any TransactionMessage, from source: Address, to destination: MeshAddress) -> Swift.Bool
  public func isTransactionContinuation(_ message: any TransactionMessage, from source: Address, to destination: MeshAddress) -> Swift.Bool
  @objc deinit
}
extension Swift.Array where Element == any StaticMeshMessage.Type {
  public func toMap() -> [Swift.UInt32 : any MeshMessage.Type]
}
public enum MeshMessageError : Swift.Error {
  case invalidAddress
  case invalidPdu
  case invalidOpCode
  public static func == (a: MeshMessageError, b: MeshMessageError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension MeshMessageError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public struct LightHSLTargetGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
public struct ConfigHeartbeatSubscriptionSet : AcknowledgedConfigMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public let source: Address
  public let destination: Address
  public let periodLog: Swift.UInt8
  public var period: Swift.UInt16 {
    get
  }
  public var enablesSubscription: Swift.Bool {
    get
  }
  public init()
  public init?(startProcessingHeartbeatMessagesFor periodLog: Swift.UInt8, secondsSentFrom source: Address, to destination: Address)
  public init?(parameters: Foundation.Data)
}
extension Element {
  public func model(withSigModelId sigModelId: Swift.UInt16) -> Model?
  public func model(withModelId modelId: Swift.UInt32) -> Model?
  public func contains(modelWithSigModelId sigModelId: Swift.UInt16) -> Swift.Bool
  public func model(withModelId modelId: Swift.UInt16, definedBy companyId: Swift.UInt16) -> Model?
  public func contains(modelWithId modelId: Swift.UInt32) -> Swift.Bool
  public func contains(model: Model) -> Swift.Bool
  public func contains(modelBoundTo applicationKey: ApplicationKey) -> Swift.Bool
  public func contains(modelSubscribedTo group: Group) -> Swift.Bool
  public func models(subscribedTo group: Group) -> [Model]
}
extension Swift.Array where Element == Element {
  public func contains(modelWithId modelId: Swift.UInt32) -> Swift.Bool
  public func contains(modelWithIdentifier modelIdentifier: Swift.UInt16) -> Swift.Bool
  public func contains(model: Model) -> Swift.Bool
  public func contains(modelSubscribedTo group: Group) -> Swift.Bool
  public func models(subscribedTo group: Group) -> [Model]
}
public struct ConfigModelAppStatus : ConfigAppKeyMessage, ConfigAnyModelMessage, ConfigStatusMessage {
  public static let opCode: Swift.UInt32
  public var parameters: Foundation.Data? {
    get
  }
  public let applicationKeyIndex: KeyIndex
  public let elementAddress: Address
  public let modelIdentifier: Swift.UInt16
  public let companyIdentifier: Swift.UInt16?
  public let status: ConfigMessageStatus
  public init<T>(confirm request: T) where T : ConfigAnyModelMessage, T : ConfigAppKeyMessage
  public init<T>(responseTo request: T, with status: ConfigMessageStatus) where T : ConfigAnyModelMessage, T : ConfigAppKeyMessage
  public init?(parameters: Foundation.Data)
}
public class ProxyProtocolHandler {
  public init()
  public func segment(_ data: Foundation.Data, ofType messageType: PduType, toMtu mtu: Swift.Int) -> [Foundation.Data]
  public func reassemble(_ data: Foundation.Data) -> (data: Foundation.Data, messageType: PduType)?
  @objc deinit
}
public struct GenericPowerRangeGet : AcknowledgedGenericMessage {
  public static let opCode: Swift.UInt32
  public static let responseType: any StaticMeshMessage.Type
  public var parameters: Foundation.Data? {
    get
  }
  public init()
  public init?(parameters: Foundation.Data)
}
extension RangeObject {
  public func contains(_ value: Swift.UInt16) -> Swift.Bool
  public func overlaps(_ other: RangeObject) -> Swift.Bool
  public func distance(to other: RangeObject) -> Swift.UInt16
}
extension Swift.Array where Element : RangeObject {
  public func merged() -> [Element]
  public mutating func merge()
  public func contains(_ value: Swift.UInt16) -> Swift.Bool
  public func overlaps(_ other: RangeObject) -> Swift.Bool
  public func overlaps(_ otherRanges: [RangeObject]) -> Swift.Bool
}
extension AddressRange {
  public var isValid: Swift.Bool {
    get
  }
  public var isUnicastRange: Swift.Bool {
    get
  }
  public var isGroupRange: Swift.Bool {
    get
  }
}
extension SceneRange {
  public var isValid: Swift.Bool {
    get
  }
}
extension Swift.Array where Element == AddressRange {
  public var isValid: Swift.Bool {
    get
  }
  public var isUnicastRange: Swift.Bool {
    get
  }
  public var isGroupRange: Swift.Bool {
    get
  }
}
extension Swift.Array where Element == SceneRange {
  public var isValid: Swift.Bool {
    get
  }
}
extension AddressRange {
  public static let allUnicastAddresses: AddressRange
  public static let allGroupAddresses: AddressRange
}
extension SceneRange {
  public static let allScenes: SceneRange
}
extension LogLevel : Swift.Equatable {}
extension LogLevel : Swift.Hashable {}
extension LogLevel : Swift.RawRepresentable {}
extension LogCategory : Swift.Equatable {}
extension LogCategory : Swift.Hashable {}
extension LogCategory : Swift.RawRepresentable {}
extension MeshMessageSecurity : Swift.Equatable {}
extension MeshMessageSecurity : Swift.Hashable {}
extension LowerTransportError : Swift.Equatable {}
extension LowerTransportError : Swift.Hashable {}
extension SensorSamplingFunction : Swift.Equatable {}
extension SensorSamplingFunction : Swift.Hashable {}
extension SensorSamplingFunction : Swift.RawRepresentable {}
extension BearerError : Swift.Equatable {}
extension BearerError : Swift.Hashable {}
extension NodeFeature : Swift.Equatable {}
extension NodeFeature : Swift.Hashable {}
extension NodeFeature : Swift.RawRepresentable {}
extension NodeFeatureState : Swift.Equatable {}
extension NodeFeatureState : Swift.Hashable {}
extension NodeFeatureState : Swift.RawRepresentable {}
extension MeshNetworkError : Swift.Equatable {}
extension MeshNetworkError : Swift.Hashable {}
extension StepResolution : Swift.Equatable {}
extension StepResolution : Swift.Hashable {}
extension StepResolution : Swift.RawRepresentable {}
extension GenericMessageStatus : Swift.Equatable {}
extension GenericMessageStatus : Swift.Hashable {}
extension GenericMessageStatus : Swift.RawRepresentable {}
extension SceneMessageStatus : Swift.Equatable {}
extension SceneMessageStatus : Swift.Hashable {}
extension SceneMessageStatus : Swift.RawRepresentable {}
extension Security : Swift.Equatable {}
extension Security : Swift.Hashable {}
extension Security : Swift.RawRepresentable {}
extension Algorithm : Swift.Equatable {}
extension Algorithm : Swift.Hashable {}
extension ConfigMessageStatus : Swift.Equatable {}
extension ConfigMessageStatus : Swift.Hashable {}
extension ConfigMessageStatus : Swift.RawRepresentable {}
extension RemainingHeartbeatPublicationCount : Swift.Sendable {}
extension RemainingHeartbeatSubscriptionPeriod : Swift.Sendable {}
extension HeartbeatSubscriptionCount : Swift.Sendable {}
extension PduType : Swift.Equatable {}
extension PduType : Swift.Hashable {}
extension PduType : Swift.RawRepresentable {}
extension AccessError : Swift.Equatable {}
extension AccessError : Swift.Hashable {}
extension SensorSettingStatus.SensorSettingAccess : Swift.Equatable {}
extension SensorSettingStatus.SensorSettingAccess : Swift.Hashable {}
extension SensorSettingStatus.SensorSettingAccess : Swift.RawRepresentable {}
extension Location : Swift.Equatable {}
extension Location : Swift.Hashable {}
extension Location : Swift.RawRepresentable {}
extension VendorMessageOpCode : Swift.Equatable {}
extension VendorMessageOpCode : Swift.Hashable {}
extension VendorMessageOpCode : Swift.RawRepresentable {}
extension MeshMessageSendStatusCode : Swift.Equatable {}
extension MeshMessageSendStatusCode : Swift.Hashable {}
extension MeshMessageSendStatusCode : Swift.RawRepresentable {}
extension RemoteProvisioningError : Swift.Equatable {}
extension RemoteProvisioningError : Swift.Hashable {}
extension RemoteProvisioningError : Swift.RawRepresentable {}
extension OnPowerUp : Swift.Equatable {}
extension OnPowerUp : Swift.Hashable {}
extension OnPowerUp : Swift.RawRepresentable {}
extension KeyRefreshPhase : Swift.Equatable {}
extension KeyRefreshPhase : Swift.Hashable {}
extension KeyRefreshPhase : Swift.RawRepresentable {}
extension KeyRefreshPhaseTransition : Swift.Equatable {}
extension KeyRefreshPhaseTransition : Swift.Hashable {}
extension KeyRefreshPhaseTransition : Swift.RawRepresentable {}
extension OutputAction : Swift.Equatable {}
extension OutputAction : Swift.Hashable {}
extension OutputAction : Swift.RawRepresentable {}
extension InputAction : Swift.Equatable {}
extension InputAction : Swift.Hashable {}
extension InputAction : Swift.RawRepresentable {}
extension NodeIdentity : Swift.Equatable {}
extension NodeIdentity : Swift.Hashable {}
extension NodeIdentity : Swift.RawRepresentable {}
extension ProxyFilerType : Swift.Equatable {}
extension ProxyFilerType : Swift.Hashable {}
extension ProxyFilerType : Swift.RawRepresentable {}
extension GattBearerError : Swift.Equatable {}
extension GattBearerError : Swift.Hashable {}
extension BatteryPresence : Swift.Equatable {}
extension BatteryPresence : Swift.Hashable {}
extension BatteryPresence : Swift.RawRepresentable {}
extension BatteryIndicator : Swift.Equatable {}
extension BatteryIndicator : Swift.Hashable {}
extension BatteryIndicator : Swift.RawRepresentable {}
extension BatteryChargingState : Swift.Equatable {}
extension BatteryChargingState : Swift.Hashable {}
extension BatteryChargingState : Swift.RawRepresentable {}
extension BatteryServiceability : Swift.Equatable {}
extension BatteryServiceability : Swift.Hashable {}
extension BatteryServiceability : Swift.RawRepresentable {}
extension ModelError : Swift.Equatable {}
extension ModelError : Swift.Hashable {}
extension MeshMessageError : Swift.Equatable {}
extension MeshMessageError : Swift.Hashable {}
